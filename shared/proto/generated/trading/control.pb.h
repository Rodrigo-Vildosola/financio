// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: trading/control.proto
// Protobuf C++ Version: 6.32.1

#ifndef trading_2fcontrol_2eproto_2epb_2eh
#define trading_2fcontrol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6032001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "trading/common.pb.h"
#include "trading/lifecycle.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_trading_2fcontrol_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_trading_2fcontrol_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_trading_2fcontrol_2eproto;
}  // extern "C"
namespace financio {
namespace trading {
class CancelOrder;
struct CancelOrderDefaultTypeInternal;
extern CancelOrderDefaultTypeInternal _CancelOrder_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull CancelOrder_class_data_;
class ControlMessage;
struct ControlMessageDefaultTypeInternal;
extern ControlMessageDefaultTypeInternal _ControlMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ControlMessage_class_data_;
class HistoricalData;
struct HistoricalDataDefaultTypeInternal;
extern HistoricalDataDefaultTypeInternal _HistoricalData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HistoricalData_class_data_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Ping_class_data_;
class PlaceOrder;
struct PlaceOrderDefaultTypeInternal;
extern PlaceOrderDefaultTypeInternal _PlaceOrder_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlaceOrder_class_data_;
class SubscribeMarketData;
struct SubscribeMarketDataDefaultTypeInternal;
extern SubscribeMarketDataDefaultTypeInternal _SubscribeMarketData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SubscribeMarketData_class_data_;
class UnsubscribeMarketData;
struct UnsubscribeMarketDataDefaultTypeInternal;
extern UnsubscribeMarketDataDefaultTypeInternal _UnsubscribeMarketData_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UnsubscribeMarketData_class_data_;
}  // namespace trading
}  // namespace financio
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace financio {
namespace trading {

// ===================================================================


// -------------------------------------------------------------------

class UnsubscribeMarketData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.UnsubscribeMarketData) */ {
 public:
  inline UnsubscribeMarketData() : UnsubscribeMarketData(nullptr) {}
  ~UnsubscribeMarketData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UnsubscribeMarketData* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UnsubscribeMarketData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnsubscribeMarketData(::google::protobuf::internal::ConstantInitialized);

  inline UnsubscribeMarketData(const UnsubscribeMarketData& from) : UnsubscribeMarketData(nullptr, from) {}
  inline UnsubscribeMarketData(UnsubscribeMarketData&& from) noexcept
      : UnsubscribeMarketData(nullptr, ::std::move(from)) {}
  inline UnsubscribeMarketData& operator=(const UnsubscribeMarketData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeMarketData& operator=(UnsubscribeMarketData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeMarketData& default_instance() {
    return *reinterpret_cast<const UnsubscribeMarketData*>(
        &_UnsubscribeMarketData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(UnsubscribeMarketData& a, UnsubscribeMarketData& b) { a.Swap(&b); }
  inline void Swap(UnsubscribeMarketData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeMarketData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeMarketData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UnsubscribeMarketData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnsubscribeMarketData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnsubscribeMarketData& from) { UnsubscribeMarketData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UnsubscribeMarketData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.UnsubscribeMarketData"; }

 protected:
  explicit UnsubscribeMarketData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UnsubscribeMarketData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UnsubscribeMarketData& from);
  UnsubscribeMarketData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UnsubscribeMarketData&& from) noexcept
      : UnsubscribeMarketData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
    kExchangeFieldNumber = 2,
    kCurrencyFieldNumber = 3,
    kSecTypeFieldNumber = 4,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const ::std::string& symbol() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_symbol();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_symbol();
  void set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_symbol() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_symbol();

  public:
  // string exchange = 2;
  void clear_exchange() ;
  const ::std::string& exchange() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_exchange(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_exchange();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_exchange();
  void set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_exchange() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_exchange(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_exchange();

  public:
  // string currency = 3;
  void clear_currency() ;
  const ::std::string& currency() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_currency(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_currency();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_currency();
  void set_allocated_currency(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_currency() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_currency();

  public:
  // string sec_type = 4;
  void clear_sec_type() ;
  const ::std::string& sec_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sec_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sec_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sec_type();
  void set_allocated_sec_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sec_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sec_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sec_type();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.UnsubscribeMarketData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 77,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UnsubscribeMarketData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::ArenaStringPtr exchange_;
    ::google::protobuf::internal::ArenaStringPtr currency_;
    ::google::protobuf::internal::ArenaStringPtr sec_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fcontrol_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UnsubscribeMarketData_class_data_;
// -------------------------------------------------------------------

class SubscribeMarketData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.SubscribeMarketData) */ {
 public:
  inline SubscribeMarketData() : SubscribeMarketData(nullptr) {}
  ~SubscribeMarketData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeMarketData* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeMarketData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeMarketData(::google::protobuf::internal::ConstantInitialized);

  inline SubscribeMarketData(const SubscribeMarketData& from) : SubscribeMarketData(nullptr, from) {}
  inline SubscribeMarketData(SubscribeMarketData&& from) noexcept
      : SubscribeMarketData(nullptr, ::std::move(from)) {}
  inline SubscribeMarketData& operator=(const SubscribeMarketData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeMarketData& operator=(SubscribeMarketData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeMarketData& default_instance() {
    return *reinterpret_cast<const SubscribeMarketData*>(
        &_SubscribeMarketData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SubscribeMarketData& a, SubscribeMarketData& b) { a.Swap(&b); }
  inline void Swap(SubscribeMarketData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeMarketData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeMarketData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubscribeMarketData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubscribeMarketData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubscribeMarketData& from) { SubscribeMarketData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubscribeMarketData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.SubscribeMarketData"; }

 protected:
  explicit SubscribeMarketData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SubscribeMarketData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SubscribeMarketData& from);
  SubscribeMarketData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SubscribeMarketData&& from) noexcept
      : SubscribeMarketData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
    kExchangeFieldNumber = 2,
    kCurrencyFieldNumber = 3,
    kSecTypeFieldNumber = 4,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const ::std::string& symbol() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_symbol();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_symbol();
  void set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_symbol() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_symbol();

  public:
  // string exchange = 2;
  void clear_exchange() ;
  const ::std::string& exchange() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_exchange(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_exchange();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_exchange();
  void set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_exchange() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_exchange(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_exchange();

  public:
  // string currency = 3;
  void clear_currency() ;
  const ::std::string& currency() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_currency(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_currency();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_currency();
  void set_allocated_currency(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_currency() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_currency();

  public:
  // string sec_type = 4;
  void clear_sec_type() ;
  const ::std::string& sec_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sec_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sec_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sec_type();
  void set_allocated_sec_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sec_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sec_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sec_type();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.SubscribeMarketData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 75,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SubscribeMarketData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::ArenaStringPtr exchange_;
    ::google::protobuf::internal::ArenaStringPtr currency_;
    ::google::protobuf::internal::ArenaStringPtr sec_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fcontrol_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SubscribeMarketData_class_data_;
// -------------------------------------------------------------------

class Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Ping* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Ping));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ping(::google::protobuf::internal::ConstantInitialized);

  inline Ping(const Ping& from) : Ping(nullptr, from) {}
  inline Ping(Ping&& from) noexcept
      : Ping(nullptr, ::std::move(from)) {}
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *reinterpret_cast<const Ping*>(
        &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }
  inline void Swap(Ping* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ping& from) { Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Ping* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.Ping"; }

 protected:
  explicit Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Ping(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Ping& from);
  Ping(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Ping&& from) noexcept
      : Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNoteFieldNumber = 1,
  };
  // string note = 1;
  void clear_note() ;
  const ::std::string& note() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_note(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_note();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_note();
  void set_allocated_note(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_note() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_note(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_note();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Ping& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr note_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fcontrol_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Ping_class_data_;
// -------------------------------------------------------------------

class HistoricalData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.HistoricalData) */ {
 public:
  inline HistoricalData() : HistoricalData(nullptr) {}
  ~HistoricalData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HistoricalData* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HistoricalData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HistoricalData(::google::protobuf::internal::ConstantInitialized);

  inline HistoricalData(const HistoricalData& from) : HistoricalData(nullptr, from) {}
  inline HistoricalData(HistoricalData&& from) noexcept
      : HistoricalData(nullptr, ::std::move(from)) {}
  inline HistoricalData& operator=(const HistoricalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoricalData& operator=(HistoricalData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoricalData& default_instance() {
    return *reinterpret_cast<const HistoricalData*>(
        &_HistoricalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(HistoricalData& a, HistoricalData& b) { a.Swap(&b); }
  inline void Swap(HistoricalData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoricalData* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoricalData* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HistoricalData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HistoricalData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HistoricalData& from) { HistoricalData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HistoricalData* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.HistoricalData"; }

 protected:
  explicit HistoricalData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HistoricalData(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HistoricalData& from);
  HistoricalData(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HistoricalData&& from) noexcept
      : HistoricalData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSymbolFieldNumber = 1,
    kExchangeFieldNumber = 2,
    kCurrencyFieldNumber = 3,
    kSecTypeFieldNumber = 4,
    kDurationStrFieldNumber = 5,
    kBarSizeFieldNumber = 6,
    kWhatToShowFieldNumber = 7,
    kUseRthFieldNumber = 8,
  };
  // string symbol = 1;
  void clear_symbol() ;
  const ::std::string& symbol() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_symbol();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_symbol();
  void set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_symbol() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_symbol();

  public:
  // string exchange = 2;
  void clear_exchange() ;
  const ::std::string& exchange() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_exchange(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_exchange();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_exchange();
  void set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_exchange() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_exchange(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_exchange();

  public:
  // string currency = 3;
  void clear_currency() ;
  const ::std::string& currency() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_currency(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_currency();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_currency();
  void set_allocated_currency(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_currency() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_currency();

  public:
  // string sec_type = 4;
  void clear_sec_type() ;
  const ::std::string& sec_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_sec_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_sec_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_sec_type();
  void set_allocated_sec_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_sec_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_sec_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_sec_type();

  public:
  // string duration_str = 5;
  void clear_duration_str() ;
  const ::std::string& duration_str() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_duration_str(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_duration_str();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_duration_str();
  void set_allocated_duration_str(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_duration_str() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_duration_str(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_duration_str();

  public:
  // string bar_size = 6;
  void clear_bar_size() ;
  const ::std::string& bar_size() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_bar_size(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_bar_size();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_bar_size();
  void set_allocated_bar_size(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_bar_size() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_bar_size(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_bar_size();

  public:
  // string what_to_show = 7;
  void clear_what_to_show() ;
  const ::std::string& what_to_show() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_what_to_show(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_what_to_show();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_what_to_show();
  void set_allocated_what_to_show(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_what_to_show() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_what_to_show(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_what_to_show();

  public:
  // int32 use_rth = 8;
  void clear_use_rth() ;
  ::int32_t use_rth() const;
  void set_use_rth(::int32_t value);

  private:
  ::int32_t _internal_use_rth() const;
  void _internal_set_use_rth(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.HistoricalData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8,
                                   0, 110,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HistoricalData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    ::google::protobuf::internal::ArenaStringPtr exchange_;
    ::google::protobuf::internal::ArenaStringPtr currency_;
    ::google::protobuf::internal::ArenaStringPtr sec_type_;
    ::google::protobuf::internal::ArenaStringPtr duration_str_;
    ::google::protobuf::internal::ArenaStringPtr bar_size_;
    ::google::protobuf::internal::ArenaStringPtr what_to_show_;
    ::int32_t use_rth_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fcontrol_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HistoricalData_class_data_;
// -------------------------------------------------------------------

class CancelOrder final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.CancelOrder) */ {
 public:
  inline CancelOrder() : CancelOrder(nullptr) {}
  ~CancelOrder() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CancelOrder* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CancelOrder));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelOrder(::google::protobuf::internal::ConstantInitialized);

  inline CancelOrder(const CancelOrder& from) : CancelOrder(nullptr, from) {}
  inline CancelOrder(CancelOrder&& from) noexcept
      : CancelOrder(nullptr, ::std::move(from)) {}
  inline CancelOrder& operator=(const CancelOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOrder& operator=(CancelOrder&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOrder& default_instance() {
    return *reinterpret_cast<const CancelOrder*>(
        &_CancelOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CancelOrder& a, CancelOrder& b) { a.Swap(&b); }
  inline void Swap(CancelOrder* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOrder* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOrder* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CancelOrder>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelOrder& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelOrder& from) { CancelOrder::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CancelOrder* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.CancelOrder"; }

 protected:
  explicit CancelOrder(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CancelOrder(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CancelOrder& from);
  CancelOrder(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CancelOrder&& from) noexcept
      : CancelOrder(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOrderIdFieldNumber = 1,
  };
  // int32 order_id = 1;
  void clear_order_id() ;
  ::int32_t order_id() const;
  void set_order_id(::int32_t value);

  private:
  ::int32_t _internal_order_id() const;
  void _internal_set_order_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.CancelOrder)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CancelOrder& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t order_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fcontrol_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull CancelOrder_class_data_;
// -------------------------------------------------------------------

class PlaceOrder final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.PlaceOrder) */ {
 public:
  inline PlaceOrder() : PlaceOrder(nullptr) {}
  ~PlaceOrder() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlaceOrder* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlaceOrder));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlaceOrder(::google::protobuf::internal::ConstantInitialized);

  inline PlaceOrder(const PlaceOrder& from) : PlaceOrder(nullptr, from) {}
  inline PlaceOrder(PlaceOrder&& from) noexcept
      : PlaceOrder(nullptr, ::std::move(from)) {}
  inline PlaceOrder& operator=(const PlaceOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaceOrder& operator=(PlaceOrder&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlaceOrder& default_instance() {
    return *reinterpret_cast<const PlaceOrder*>(
        &_PlaceOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(PlaceOrder& a, PlaceOrder& b) { a.Swap(&b); }
  inline void Swap(PlaceOrder* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaceOrder* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlaceOrder* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlaceOrder>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlaceOrder& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlaceOrder& from) { PlaceOrder::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlaceOrder* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.PlaceOrder"; }

 protected:
  explicit PlaceOrder(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlaceOrder(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlaceOrder& from);
  PlaceOrder(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlaceOrder&& from) noexcept
      : PlaceOrder(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kActionFieldNumber = 5,
    kOrderTypeFieldNumber = 6,
    kContractFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kLimitPxFieldNumber = 3,
    kStopPxFieldNumber = 4,
  };
  // string action = 5;
  void clear_action() ;
  const ::std::string& action() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_action(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_action();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_action();
  void set_allocated_action(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_action() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_action(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_action();

  public:
  // string order_type = 6;
  void clear_order_type() ;
  const ::std::string& order_type() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_order_type(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_order_type();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_order_type();
  void set_allocated_order_type(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_order_type() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_order_type(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_order_type();

  public:
  // .financio.trading.ContractPB contract = 1;
  bool has_contract() const;
  void clear_contract() ;
  const ::financio::trading::ContractPB& contract() const;
  [[nodiscard]] ::financio::trading::ContractPB* PROTOBUF_NULLABLE release_contract();
  ::financio::trading::ContractPB* PROTOBUF_NONNULL mutable_contract();
  void set_allocated_contract(::financio::trading::ContractPB* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_contract(::financio::trading::ContractPB* PROTOBUF_NULLABLE value);
  ::financio::trading::ContractPB* PROTOBUF_NULLABLE unsafe_arena_release_contract();

  private:
  const ::financio::trading::ContractPB& _internal_contract() const;
  ::financio::trading::ContractPB* PROTOBUF_NONNULL _internal_mutable_contract();

  public:
  // double quantity = 2;
  void clear_quantity() ;
  double quantity() const;
  void set_quantity(double value);

  private:
  double _internal_quantity() const;
  void _internal_set_quantity(double value);

  public:
  // double limit_px = 3;
  void clear_limit_px() ;
  double limit_px() const;
  void set_limit_px(double value);

  private:
  double _internal_limit_px() const;
  void _internal_set_limit_px(double value);

  public:
  // double stop_px = 4;
  void clear_stop_px() ;
  double stop_px() const;
  void set_stop_px(double value);

  private:
  double _internal_stop_px() const;
  void _internal_set_stop_px(double value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.PlaceOrder)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   1, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlaceOrder& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr action_;
    ::google::protobuf::internal::ArenaStringPtr order_type_;
    ::financio::trading::ContractPB* PROTOBUF_NULLABLE contract_;
    double quantity_;
    double limit_px_;
    double stop_px_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fcontrol_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlaceOrder_class_data_;
// -------------------------------------------------------------------

class ControlMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.ControlMessage) */ {
 public:
  inline ControlMessage() : ControlMessage(nullptr) {}
  ~ControlMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ControlMessage* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ControlMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControlMessage(::google::protobuf::internal::ConstantInitialized);

  inline ControlMessage(const ControlMessage& from) : ControlMessage(nullptr, from) {}
  inline ControlMessage(ControlMessage&& from) noexcept
      : ControlMessage(nullptr, ::std::move(from)) {}
  inline ControlMessage& operator=(const ControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlMessage& operator=(ControlMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlMessage& default_instance() {
    return *reinterpret_cast<const ControlMessage*>(
        &_ControlMessage_default_instance_);
  }
  enum PayloadCase {
    kConnect = 10,
    kSubMktData = 11,
    kUnsubMktData = 12,
    kPlaceOrder = 13,
    kCancelOrder = 14,
    kReqHistoricalData = 15,
    kPing = 16,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ControlMessage& a, ControlMessage& b) { a.Swap(&b); }
  inline void Swap(ControlMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ControlMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ControlMessage& from) { ControlMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ControlMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.ControlMessage"; }

 protected:
  explicit ControlMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ControlMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ControlMessage& from);
  ControlMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ControlMessage&& from) noexcept
      : ControlMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kIdFieldNumber = 2,
    kConnectFieldNumber = 10,
    kSubMktDataFieldNumber = 11,
    kUnsubMktDataFieldNumber = 12,
    kPlaceOrderFieldNumber = 13,
    kCancelOrderFieldNumber = 14,
    kReqHistoricalDataFieldNumber = 15,
    kPingFieldNumber = 16,
  };
  // .financio.trading.ControlType type = 1;
  void clear_type() ;
  ::financio::trading::ControlType type() const;
  void set_type(::financio::trading::ControlType value);

  private:
  ::financio::trading::ControlType _internal_type() const;
  void _internal_set_type(::financio::trading::ControlType value);

  public:
  // int32 id = 2;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // .financio.trading.ConnectBroker connect = 10;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;

  public:
  void clear_connect() ;
  const ::financio::trading::ConnectBroker& connect() const;
  [[nodiscard]] ::financio::trading::ConnectBroker* PROTOBUF_NULLABLE release_connect();
  ::financio::trading::ConnectBroker* PROTOBUF_NONNULL mutable_connect();
  void set_allocated_connect(::financio::trading::ConnectBroker* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_connect(::financio::trading::ConnectBroker* PROTOBUF_NULLABLE value);
  ::financio::trading::ConnectBroker* PROTOBUF_NULLABLE unsafe_arena_release_connect();

  private:
  const ::financio::trading::ConnectBroker& _internal_connect() const;
  ::financio::trading::ConnectBroker* PROTOBUF_NONNULL _internal_mutable_connect();

  public:
  // .financio.trading.SubscribeMarketData sub_mkt_data = 11;
  bool has_sub_mkt_data() const;
  private:
  bool _internal_has_sub_mkt_data() const;

  public:
  void clear_sub_mkt_data() ;
  const ::financio::trading::SubscribeMarketData& sub_mkt_data() const;
  [[nodiscard]] ::financio::trading::SubscribeMarketData* PROTOBUF_NULLABLE release_sub_mkt_data();
  ::financio::trading::SubscribeMarketData* PROTOBUF_NONNULL mutable_sub_mkt_data();
  void set_allocated_sub_mkt_data(::financio::trading::SubscribeMarketData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sub_mkt_data(::financio::trading::SubscribeMarketData* PROTOBUF_NULLABLE value);
  ::financio::trading::SubscribeMarketData* PROTOBUF_NULLABLE unsafe_arena_release_sub_mkt_data();

  private:
  const ::financio::trading::SubscribeMarketData& _internal_sub_mkt_data() const;
  ::financio::trading::SubscribeMarketData* PROTOBUF_NONNULL _internal_mutable_sub_mkt_data();

  public:
  // .financio.trading.UnsubscribeMarketData unsub_mkt_data = 12;
  bool has_unsub_mkt_data() const;
  private:
  bool _internal_has_unsub_mkt_data() const;

  public:
  void clear_unsub_mkt_data() ;
  const ::financio::trading::UnsubscribeMarketData& unsub_mkt_data() const;
  [[nodiscard]] ::financio::trading::UnsubscribeMarketData* PROTOBUF_NULLABLE release_unsub_mkt_data();
  ::financio::trading::UnsubscribeMarketData* PROTOBUF_NONNULL mutable_unsub_mkt_data();
  void set_allocated_unsub_mkt_data(::financio::trading::UnsubscribeMarketData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_unsub_mkt_data(::financio::trading::UnsubscribeMarketData* PROTOBUF_NULLABLE value);
  ::financio::trading::UnsubscribeMarketData* PROTOBUF_NULLABLE unsafe_arena_release_unsub_mkt_data();

  private:
  const ::financio::trading::UnsubscribeMarketData& _internal_unsub_mkt_data() const;
  ::financio::trading::UnsubscribeMarketData* PROTOBUF_NONNULL _internal_mutable_unsub_mkt_data();

  public:
  // .financio.trading.PlaceOrder place_order = 13;
  bool has_place_order() const;
  private:
  bool _internal_has_place_order() const;

  public:
  void clear_place_order() ;
  const ::financio::trading::PlaceOrder& place_order() const;
  [[nodiscard]] ::financio::trading::PlaceOrder* PROTOBUF_NULLABLE release_place_order();
  ::financio::trading::PlaceOrder* PROTOBUF_NONNULL mutable_place_order();
  void set_allocated_place_order(::financio::trading::PlaceOrder* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_place_order(::financio::trading::PlaceOrder* PROTOBUF_NULLABLE value);
  ::financio::trading::PlaceOrder* PROTOBUF_NULLABLE unsafe_arena_release_place_order();

  private:
  const ::financio::trading::PlaceOrder& _internal_place_order() const;
  ::financio::trading::PlaceOrder* PROTOBUF_NONNULL _internal_mutable_place_order();

  public:
  // .financio.trading.CancelOrder cancel_order = 14;
  bool has_cancel_order() const;
  private:
  bool _internal_has_cancel_order() const;

  public:
  void clear_cancel_order() ;
  const ::financio::trading::CancelOrder& cancel_order() const;
  [[nodiscard]] ::financio::trading::CancelOrder* PROTOBUF_NULLABLE release_cancel_order();
  ::financio::trading::CancelOrder* PROTOBUF_NONNULL mutable_cancel_order();
  void set_allocated_cancel_order(::financio::trading::CancelOrder* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_cancel_order(::financio::trading::CancelOrder* PROTOBUF_NULLABLE value);
  ::financio::trading::CancelOrder* PROTOBUF_NULLABLE unsafe_arena_release_cancel_order();

  private:
  const ::financio::trading::CancelOrder& _internal_cancel_order() const;
  ::financio::trading::CancelOrder* PROTOBUF_NONNULL _internal_mutable_cancel_order();

  public:
  // .financio.trading.HistoricalData req_historical_data = 15;
  bool has_req_historical_data() const;
  private:
  bool _internal_has_req_historical_data() const;

  public:
  void clear_req_historical_data() ;
  const ::financio::trading::HistoricalData& req_historical_data() const;
  [[nodiscard]] ::financio::trading::HistoricalData* PROTOBUF_NULLABLE release_req_historical_data();
  ::financio::trading::HistoricalData* PROTOBUF_NONNULL mutable_req_historical_data();
  void set_allocated_req_historical_data(::financio::trading::HistoricalData* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_req_historical_data(::financio::trading::HistoricalData* PROTOBUF_NULLABLE value);
  ::financio::trading::HistoricalData* PROTOBUF_NULLABLE unsafe_arena_release_req_historical_data();

  private:
  const ::financio::trading::HistoricalData& _internal_req_historical_data() const;
  ::financio::trading::HistoricalData* PROTOBUF_NONNULL _internal_mutable_req_historical_data();

  public:
  // .financio.trading.Ping ping = 16;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;

  public:
  void clear_ping() ;
  const ::financio::trading::Ping& ping() const;
  [[nodiscard]] ::financio::trading::Ping* PROTOBUF_NULLABLE release_ping();
  ::financio::trading::Ping* PROTOBUF_NONNULL mutable_ping();
  void set_allocated_ping(::financio::trading::Ping* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ping(::financio::trading::Ping* PROTOBUF_NULLABLE value);
  ::financio::trading::Ping* PROTOBUF_NULLABLE unsafe_arena_release_ping();

  private:
  const ::financio::trading::Ping& _internal_ping() const;
  ::financio::trading::Ping* PROTOBUF_NONNULL _internal_mutable_ping();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:financio.trading.ControlMessage)
 private:
  class _Internal;
  void set_has_connect();
  void set_has_sub_mkt_data();
  void set_has_unsub_mkt_data();
  void set_has_place_order();
  void set_has_cancel_order();
  void set_has_req_historical_data();
  void set_has_ping();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 9,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ControlMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    ::int32_t id_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE connect_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sub_mkt_data_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE unsub_mkt_data_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE place_order_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE cancel_order_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE req_historical_data_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE ping_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fcontrol_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ControlMessage_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SubscribeMarketData

// string symbol = 1;
inline void SubscribeMarketData::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& SubscribeMarketData::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.SubscribeMarketData.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeMarketData::set_symbol(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.SubscribeMarketData.symbol)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::mutable_symbol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:financio.trading.SubscribeMarketData.symbol)
  return _s;
}
inline const ::std::string& SubscribeMarketData::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void SubscribeMarketData::_internal_set_symbol(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.symbol_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.symbol_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeMarketData::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.SubscribeMarketData.symbol)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.symbol_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.symbol_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeMarketData::set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.SubscribeMarketData.symbol)
}

// string exchange = 2;
inline void SubscribeMarketData::clear_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exchange_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& SubscribeMarketData::exchange() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.SubscribeMarketData.exchange)
  return _internal_exchange();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeMarketData::set_exchange(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.exchange_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.SubscribeMarketData.exchange)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::mutable_exchange()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:financio.trading.SubscribeMarketData.exchange)
  return _s;
}
inline const ::std::string& SubscribeMarketData::_internal_exchange() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exchange_.Get();
}
inline void SubscribeMarketData::_internal_set_exchange(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.exchange_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::_internal_mutable_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.exchange_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeMarketData::release_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.SubscribeMarketData.exchange)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.exchange_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.exchange_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeMarketData::set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.exchange_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.exchange_.IsDefault()) {
    _impl_.exchange_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.SubscribeMarketData.exchange)
}

// string currency = 3;
inline void SubscribeMarketData::clear_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.currency_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::std::string& SubscribeMarketData::currency() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.SubscribeMarketData.currency)
  return _internal_currency();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeMarketData::set_currency(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.currency_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.SubscribeMarketData.currency)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::mutable_currency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:financio.trading.SubscribeMarketData.currency)
  return _s;
}
inline const ::std::string& SubscribeMarketData::_internal_currency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.currency_.Get();
}
inline void SubscribeMarketData::_internal_set_currency(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.currency_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::_internal_mutable_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  return _impl_.currency_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeMarketData::release_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.SubscribeMarketData.currency)
  if ((_impl_._has_bits_[0] & 0x00000004U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004U;
  auto* released = _impl_.currency_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.currency_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeMarketData::set_allocated_currency(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  _impl_.currency_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.SubscribeMarketData.currency)
}

// string sec_type = 4;
inline void SubscribeMarketData::clear_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sec_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline const ::std::string& SubscribeMarketData::sec_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.SubscribeMarketData.sec_type)
  return _internal_sec_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SubscribeMarketData::set_sec_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.sec_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.SubscribeMarketData.sec_type)
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::mutable_sec_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_sec_type();
  // @@protoc_insertion_point(field_mutable:financio.trading.SubscribeMarketData.sec_type)
  return _s;
}
inline const ::std::string& SubscribeMarketData::_internal_sec_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sec_type_.Get();
}
inline void SubscribeMarketData::_internal_set_sec_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.sec_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SubscribeMarketData::_internal_mutable_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  return _impl_.sec_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SubscribeMarketData::release_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.SubscribeMarketData.sec_type)
  if ((_impl_._has_bits_[0] & 0x00000008U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008U;
  auto* released = _impl_.sec_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sec_type_.Set("", GetArena());
  }
  return released;
}
inline void SubscribeMarketData::set_allocated_sec_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }
  _impl_.sec_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sec_type_.IsDefault()) {
    _impl_.sec_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.SubscribeMarketData.sec_type)
}

// -------------------------------------------------------------------

// UnsubscribeMarketData

// string symbol = 1;
inline void UnsubscribeMarketData::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& UnsubscribeMarketData::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.UnsubscribeMarketData.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UnsubscribeMarketData::set_symbol(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.UnsubscribeMarketData.symbol)
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::mutable_symbol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:financio.trading.UnsubscribeMarketData.symbol)
  return _s;
}
inline const ::std::string& UnsubscribeMarketData::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void UnsubscribeMarketData::_internal_set_symbol(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.symbol_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.symbol_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UnsubscribeMarketData::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.UnsubscribeMarketData.symbol)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.symbol_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.symbol_.Set("", GetArena());
  }
  return released;
}
inline void UnsubscribeMarketData::set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.UnsubscribeMarketData.symbol)
}

// string exchange = 2;
inline void UnsubscribeMarketData::clear_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exchange_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& UnsubscribeMarketData::exchange() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.UnsubscribeMarketData.exchange)
  return _internal_exchange();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UnsubscribeMarketData::set_exchange(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.exchange_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.UnsubscribeMarketData.exchange)
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::mutable_exchange()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:financio.trading.UnsubscribeMarketData.exchange)
  return _s;
}
inline const ::std::string& UnsubscribeMarketData::_internal_exchange() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exchange_.Get();
}
inline void UnsubscribeMarketData::_internal_set_exchange(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.exchange_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::_internal_mutable_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.exchange_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UnsubscribeMarketData::release_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.UnsubscribeMarketData.exchange)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.exchange_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.exchange_.Set("", GetArena());
  }
  return released;
}
inline void UnsubscribeMarketData::set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.exchange_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.exchange_.IsDefault()) {
    _impl_.exchange_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.UnsubscribeMarketData.exchange)
}

// string currency = 3;
inline void UnsubscribeMarketData::clear_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.currency_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::std::string& UnsubscribeMarketData::currency() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.UnsubscribeMarketData.currency)
  return _internal_currency();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UnsubscribeMarketData::set_currency(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.currency_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.UnsubscribeMarketData.currency)
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::mutable_currency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:financio.trading.UnsubscribeMarketData.currency)
  return _s;
}
inline const ::std::string& UnsubscribeMarketData::_internal_currency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.currency_.Get();
}
inline void UnsubscribeMarketData::_internal_set_currency(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.currency_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::_internal_mutable_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  return _impl_.currency_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UnsubscribeMarketData::release_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.UnsubscribeMarketData.currency)
  if ((_impl_._has_bits_[0] & 0x00000004U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004U;
  auto* released = _impl_.currency_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.currency_.Set("", GetArena());
  }
  return released;
}
inline void UnsubscribeMarketData::set_allocated_currency(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  _impl_.currency_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.UnsubscribeMarketData.currency)
}

// string sec_type = 4;
inline void UnsubscribeMarketData::clear_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sec_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline const ::std::string& UnsubscribeMarketData::sec_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.UnsubscribeMarketData.sec_type)
  return _internal_sec_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UnsubscribeMarketData::set_sec_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.sec_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.UnsubscribeMarketData.sec_type)
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::mutable_sec_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_sec_type();
  // @@protoc_insertion_point(field_mutable:financio.trading.UnsubscribeMarketData.sec_type)
  return _s;
}
inline const ::std::string& UnsubscribeMarketData::_internal_sec_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sec_type_.Get();
}
inline void UnsubscribeMarketData::_internal_set_sec_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.sec_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UnsubscribeMarketData::_internal_mutable_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  return _impl_.sec_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UnsubscribeMarketData::release_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.UnsubscribeMarketData.sec_type)
  if ((_impl_._has_bits_[0] & 0x00000008U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008U;
  auto* released = _impl_.sec_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sec_type_.Set("", GetArena());
  }
  return released;
}
inline void UnsubscribeMarketData::set_allocated_sec_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }
  _impl_.sec_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sec_type_.IsDefault()) {
    _impl_.sec_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.UnsubscribeMarketData.sec_type)
}

// -------------------------------------------------------------------

// PlaceOrder

// .financio.trading.ContractPB contract = 1;
inline bool PlaceOrder::has_contract() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contract_ != nullptr);
  return value;
}
inline const ::financio::trading::ContractPB& PlaceOrder::_internal_contract() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::financio::trading::ContractPB* p = _impl_.contract_;
  return p != nullptr ? *p : reinterpret_cast<const ::financio::trading::ContractPB&>(::financio::trading::_ContractPB_default_instance_);
}
inline const ::financio::trading::ContractPB& PlaceOrder::contract() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.PlaceOrder.contract)
  return _internal_contract();
}
inline void PlaceOrder::unsafe_arena_set_allocated_contract(
    ::financio::trading::ContractPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contract_);
  }
  _impl_.contract_ = reinterpret_cast<::financio::trading::ContractPB*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.PlaceOrder.contract)
}
inline ::financio::trading::ContractPB* PROTOBUF_NULLABLE PlaceOrder::release_contract() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::financio::trading::ContractPB* released = _impl_.contract_;
  _impl_.contract_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::financio::trading::ContractPB* PROTOBUF_NULLABLE PlaceOrder::unsafe_arena_release_contract() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.PlaceOrder.contract)

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::financio::trading::ContractPB* temp = _impl_.contract_;
  _impl_.contract_ = nullptr;
  return temp;
}
inline ::financio::trading::ContractPB* PROTOBUF_NONNULL PlaceOrder::_internal_mutable_contract() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.contract_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::financio::trading::ContractPB>(GetArena());
    _impl_.contract_ = reinterpret_cast<::financio::trading::ContractPB*>(p);
  }
  return _impl_.contract_;
}
inline ::financio::trading::ContractPB* PROTOBUF_NONNULL PlaceOrder::mutable_contract()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004U;
  ::financio::trading::ContractPB* _msg = _internal_mutable_contract();
  // @@protoc_insertion_point(field_mutable:financio.trading.PlaceOrder.contract)
  return _msg;
}
inline void PlaceOrder::set_allocated_contract(::financio::trading::ContractPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.contract_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }

  _impl_.contract_ = reinterpret_cast<::financio::trading::ContractPB*>(value);
  // @@protoc_insertion_point(field_set_allocated:financio.trading.PlaceOrder.contract)
}

// double quantity = 2;
inline void PlaceOrder::clear_quantity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline double PlaceOrder::quantity() const {
  // @@protoc_insertion_point(field_get:financio.trading.PlaceOrder.quantity)
  return _internal_quantity();
}
inline void PlaceOrder::set_quantity(double value) {
  _internal_set_quantity(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:financio.trading.PlaceOrder.quantity)
}
inline double PlaceOrder::_internal_quantity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.quantity_;
}
inline void PlaceOrder::_internal_set_quantity(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.quantity_ = value;
}

// double limit_px = 3;
inline void PlaceOrder::clear_limit_px() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_px_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline double PlaceOrder::limit_px() const {
  // @@protoc_insertion_point(field_get:financio.trading.PlaceOrder.limit_px)
  return _internal_limit_px();
}
inline void PlaceOrder::set_limit_px(double value) {
  _internal_set_limit_px(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:financio.trading.PlaceOrder.limit_px)
}
inline double PlaceOrder::_internal_limit_px() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_px_;
}
inline void PlaceOrder::_internal_set_limit_px(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_px_ = value;
}

// double stop_px = 4;
inline void PlaceOrder::clear_stop_px() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_px_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline double PlaceOrder::stop_px() const {
  // @@protoc_insertion_point(field_get:financio.trading.PlaceOrder.stop_px)
  return _internal_stop_px();
}
inline void PlaceOrder::set_stop_px(double value) {
  _internal_set_stop_px(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:financio.trading.PlaceOrder.stop_px)
}
inline double PlaceOrder::_internal_stop_px() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_px_;
}
inline void PlaceOrder::_internal_set_stop_px(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_px_ = value;
}

// string action = 5;
inline void PlaceOrder::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& PlaceOrder::action() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.PlaceOrder.action)
  return _internal_action();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlaceOrder::set_action(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.action_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.PlaceOrder.action)
}
inline ::std::string* PROTOBUF_NONNULL PlaceOrder::mutable_action()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:financio.trading.PlaceOrder.action)
  return _s;
}
inline const ::std::string& PlaceOrder::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.action_.Get();
}
inline void PlaceOrder::_internal_set_action(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.action_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlaceOrder::_internal_mutable_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.action_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlaceOrder::release_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.PlaceOrder.action)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.action_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.action_.Set("", GetArena());
  }
  return released;
}
inline void PlaceOrder::set_allocated_action(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.action_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.PlaceOrder.action)
}

// string order_type = 6;
inline void PlaceOrder::clear_order_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& PlaceOrder::order_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.PlaceOrder.order_type)
  return _internal_order_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlaceOrder::set_order_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.order_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.PlaceOrder.order_type)
}
inline ::std::string* PROTOBUF_NONNULL PlaceOrder::mutable_order_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_order_type();
  // @@protoc_insertion_point(field_mutable:financio.trading.PlaceOrder.order_type)
  return _s;
}
inline const ::std::string& PlaceOrder::_internal_order_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_type_.Get();
}
inline void PlaceOrder::_internal_set_order_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.order_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlaceOrder::_internal_mutable_order_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.order_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlaceOrder::release_order_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.PlaceOrder.order_type)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.order_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.order_type_.Set("", GetArena());
  }
  return released;
}
inline void PlaceOrder::set_allocated_order_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.order_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.order_type_.IsDefault()) {
    _impl_.order_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.PlaceOrder.order_type)
}

// -------------------------------------------------------------------

// CancelOrder

// int32 order_id = 1;
inline void CancelOrder::clear_order_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::int32_t CancelOrder::order_id() const {
  // @@protoc_insertion_point(field_get:financio.trading.CancelOrder.order_id)
  return _internal_order_id();
}
inline void CancelOrder::set_order_id(::int32_t value) {
  _internal_set_order_id(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:financio.trading.CancelOrder.order_id)
}
inline ::int32_t CancelOrder::_internal_order_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.order_id_;
}
inline void CancelOrder::_internal_set_order_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.order_id_ = value;
}

// -------------------------------------------------------------------

// HistoricalData

// string symbol = 1;
inline void HistoricalData::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& HistoricalData::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalData::set_symbol(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.symbol)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::mutable_symbol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalData.symbol)
  return _s;
}
inline const ::std::string& HistoricalData::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void HistoricalData::_internal_set_symbol(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.symbol_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.symbol_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalData::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalData.symbol)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.symbol_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.symbol_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalData::set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalData.symbol)
}

// string exchange = 2;
inline void HistoricalData::clear_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exchange_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& HistoricalData::exchange() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.exchange)
  return _internal_exchange();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalData::set_exchange(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.exchange_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.exchange)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::mutable_exchange()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalData.exchange)
  return _s;
}
inline const ::std::string& HistoricalData::_internal_exchange() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exchange_.Get();
}
inline void HistoricalData::_internal_set_exchange(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.exchange_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::_internal_mutable_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.exchange_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalData::release_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalData.exchange)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.exchange_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.exchange_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalData::set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.exchange_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.exchange_.IsDefault()) {
    _impl_.exchange_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalData.exchange)
}

// string currency = 3;
inline void HistoricalData::clear_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.currency_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::std::string& HistoricalData::currency() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.currency)
  return _internal_currency();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalData::set_currency(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.currency_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.currency)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::mutable_currency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalData.currency)
  return _s;
}
inline const ::std::string& HistoricalData::_internal_currency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.currency_.Get();
}
inline void HistoricalData::_internal_set_currency(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.currency_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::_internal_mutable_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  return _impl_.currency_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalData::release_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalData.currency)
  if ((_impl_._has_bits_[0] & 0x00000004U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004U;
  auto* released = _impl_.currency_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.currency_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalData::set_allocated_currency(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  _impl_.currency_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalData.currency)
}

// string sec_type = 4;
inline void HistoricalData::clear_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sec_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline const ::std::string& HistoricalData::sec_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.sec_type)
  return _internal_sec_type();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalData::set_sec_type(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.sec_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.sec_type)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::mutable_sec_type()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_sec_type();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalData.sec_type)
  return _s;
}
inline const ::std::string& HistoricalData::_internal_sec_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sec_type_.Get();
}
inline void HistoricalData::_internal_set_sec_type(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.sec_type_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::_internal_mutable_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  return _impl_.sec_type_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalData::release_sec_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalData.sec_type)
  if ((_impl_._has_bits_[0] & 0x00000008U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008U;
  auto* released = _impl_.sec_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.sec_type_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalData::set_allocated_sec_type(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }
  _impl_.sec_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sec_type_.IsDefault()) {
    _impl_.sec_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalData.sec_type)
}

// string duration_str = 5;
inline void HistoricalData::clear_duration_str() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline const ::std::string& HistoricalData::duration_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.duration_str)
  return _internal_duration_str();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalData::set_duration_str(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010U;
  _impl_.duration_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.duration_str)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::mutable_duration_str()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_duration_str();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalData.duration_str)
  return _s;
}
inline const ::std::string& HistoricalData::_internal_duration_str() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_str_.Get();
}
inline void HistoricalData::_internal_set_duration_str(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010U;
  _impl_.duration_str_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::_internal_mutable_duration_str() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010U;
  return _impl_.duration_str_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalData::release_duration_str() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalData.duration_str)
  if ((_impl_._has_bits_[0] & 0x00000010U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010U;
  auto* released = _impl_.duration_str_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.duration_str_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalData::set_allocated_duration_str(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010U;
  }
  _impl_.duration_str_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.duration_str_.IsDefault()) {
    _impl_.duration_str_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalData.duration_str)
}

// string bar_size = 6;
inline void HistoricalData::clear_bar_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bar_size_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline const ::std::string& HistoricalData::bar_size() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.bar_size)
  return _internal_bar_size();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalData::set_bar_size(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020U;
  _impl_.bar_size_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.bar_size)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::mutable_bar_size()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_bar_size();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalData.bar_size)
  return _s;
}
inline const ::std::string& HistoricalData::_internal_bar_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bar_size_.Get();
}
inline void HistoricalData::_internal_set_bar_size(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020U;
  _impl_.bar_size_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::_internal_mutable_bar_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020U;
  return _impl_.bar_size_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalData::release_bar_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalData.bar_size)
  if ((_impl_._has_bits_[0] & 0x00000020U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020U;
  auto* released = _impl_.bar_size_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.bar_size_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalData::set_allocated_bar_size(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020U;
  }
  _impl_.bar_size_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bar_size_.IsDefault()) {
    _impl_.bar_size_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalData.bar_size)
}

// string what_to_show = 7;
inline void HistoricalData::clear_what_to_show() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.what_to_show_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040U;
}
inline const ::std::string& HistoricalData::what_to_show() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.what_to_show)
  return _internal_what_to_show();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalData::set_what_to_show(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040U;
  _impl_.what_to_show_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.what_to_show)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::mutable_what_to_show()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_what_to_show();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalData.what_to_show)
  return _s;
}
inline const ::std::string& HistoricalData::_internal_what_to_show() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.what_to_show_.Get();
}
inline void HistoricalData::_internal_set_what_to_show(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040U;
  _impl_.what_to_show_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalData::_internal_mutable_what_to_show() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040U;
  return _impl_.what_to_show_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalData::release_what_to_show() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalData.what_to_show)
  if ((_impl_._has_bits_[0] & 0x00000040U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040U;
  auto* released = _impl_.what_to_show_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.what_to_show_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalData::set_allocated_what_to_show(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040U;
  }
  _impl_.what_to_show_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.what_to_show_.IsDefault()) {
    _impl_.what_to_show_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalData.what_to_show)
}

// int32 use_rth = 8;
inline void HistoricalData::clear_use_rth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_rth_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080U;
}
inline ::int32_t HistoricalData::use_rth() const {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalData.use_rth)
  return _internal_use_rth();
}
inline void HistoricalData::set_use_rth(::int32_t value) {
  _internal_set_use_rth(value);
  _impl_._has_bits_[0] |= 0x00000080U;
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalData.use_rth)
}
inline ::int32_t HistoricalData::_internal_use_rth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.use_rth_;
}
inline void HistoricalData::_internal_set_use_rth(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_rth_ = value;
}

// -------------------------------------------------------------------

// Ping

// string note = 1;
inline void Ping::clear_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.note_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& Ping::note() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.Ping.note)
  return _internal_note();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Ping::set_note(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.note_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.Ping.note)
}
inline ::std::string* PROTOBUF_NONNULL Ping::mutable_note()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:financio.trading.Ping.note)
  return _s;
}
inline const ::std::string& Ping::_internal_note() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.note_.Get();
}
inline void Ping::_internal_set_note(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.note_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Ping::_internal_mutable_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.note_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Ping::release_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.Ping.note)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.note_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.note_.Set("", GetArena());
  }
  return released;
}
inline void Ping::set_allocated_note(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.note_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.Ping.note)
}

// -------------------------------------------------------------------

// ControlMessage

// .financio.trading.ControlType type = 1;
inline void ControlMessage::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::financio::trading::ControlType ControlMessage::type() const {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.type)
  return _internal_type();
}
inline void ControlMessage::set_type(::financio::trading::ControlType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:financio.trading.ControlMessage.type)
}
inline ::financio::trading::ControlType ControlMessage::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::financio::trading::ControlType>(_impl_.type_);
}
inline void ControlMessage::_internal_set_type(::financio::trading::ControlType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// int32 id = 2;
inline void ControlMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::int32_t ControlMessage::id() const {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.id)
  return _internal_id();
}
inline void ControlMessage::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:financio.trading.ControlMessage.id)
}
inline ::int32_t ControlMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void ControlMessage::_internal_set_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .financio.trading.ConnectBroker connect = 10;
inline bool ControlMessage::has_connect() const {
  return payload_case() == kConnect;
}
inline bool ControlMessage::_internal_has_connect() const {
  return payload_case() == kConnect;
}
inline void ControlMessage::set_has_connect() {
  _impl_._oneof_case_[0] = kConnect;
}
inline ::financio::trading::ConnectBroker* PROTOBUF_NULLABLE ControlMessage::release_connect() {
  // @@protoc_insertion_point(field_release:financio.trading.ControlMessage.connect)
  if (payload_case() == kConnect) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::ConnectBroker*>(_impl_.payload_.connect_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::ConnectBroker& ControlMessage::_internal_connect() const {
  return payload_case() == kConnect ? *reinterpret_cast<::financio::trading::ConnectBroker*>(_impl_.payload_.connect_) : reinterpret_cast<::financio::trading::ConnectBroker&>(::financio::trading::_ConnectBroker_default_instance_);
}
inline const ::financio::trading::ConnectBroker& ControlMessage::connect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.connect)
  return _internal_connect();
}
inline ::financio::trading::ConnectBroker* PROTOBUF_NULLABLE ControlMessage::unsafe_arena_release_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.ControlMessage.connect)
  if (payload_case() == kConnect) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::ConnectBroker*>(_impl_.payload_.connect_);
    _impl_.payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlMessage::unsafe_arena_set_allocated_connect(
    ::financio::trading::ConnectBroker* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_connect();
    _impl_.payload_.connect_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.ControlMessage.connect)
}
inline ::financio::trading::ConnectBroker* PROTOBUF_NONNULL ControlMessage::_internal_mutable_connect() {
  if (payload_case() != kConnect) {
    clear_payload();
    set_has_connect();
    _impl_.payload_.connect_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::ConnectBroker>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::ConnectBroker*>(_impl_.payload_.connect_);
}
inline ::financio::trading::ConnectBroker* PROTOBUF_NONNULL ControlMessage::mutable_connect()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::ConnectBroker* _msg = _internal_mutable_connect();
  // @@protoc_insertion_point(field_mutable:financio.trading.ControlMessage.connect)
  return _msg;
}

// .financio.trading.SubscribeMarketData sub_mkt_data = 11;
inline bool ControlMessage::has_sub_mkt_data() const {
  return payload_case() == kSubMktData;
}
inline bool ControlMessage::_internal_has_sub_mkt_data() const {
  return payload_case() == kSubMktData;
}
inline void ControlMessage::set_has_sub_mkt_data() {
  _impl_._oneof_case_[0] = kSubMktData;
}
inline void ControlMessage::clear_sub_mkt_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSubMktData) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.sub_mkt_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.sub_mkt_data_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::SubscribeMarketData* PROTOBUF_NULLABLE ControlMessage::release_sub_mkt_data() {
  // @@protoc_insertion_point(field_release:financio.trading.ControlMessage.sub_mkt_data)
  if (payload_case() == kSubMktData) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::SubscribeMarketData*>(_impl_.payload_.sub_mkt_data_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.sub_mkt_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::SubscribeMarketData& ControlMessage::_internal_sub_mkt_data() const {
  return payload_case() == kSubMktData ? *reinterpret_cast<::financio::trading::SubscribeMarketData*>(_impl_.payload_.sub_mkt_data_) : reinterpret_cast<::financio::trading::SubscribeMarketData&>(::financio::trading::_SubscribeMarketData_default_instance_);
}
inline const ::financio::trading::SubscribeMarketData& ControlMessage::sub_mkt_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.sub_mkt_data)
  return _internal_sub_mkt_data();
}
inline ::financio::trading::SubscribeMarketData* PROTOBUF_NULLABLE ControlMessage::unsafe_arena_release_sub_mkt_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.ControlMessage.sub_mkt_data)
  if (payload_case() == kSubMktData) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::SubscribeMarketData*>(_impl_.payload_.sub_mkt_data_);
    _impl_.payload_.sub_mkt_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlMessage::unsafe_arena_set_allocated_sub_mkt_data(
    ::financio::trading::SubscribeMarketData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_sub_mkt_data();
    _impl_.payload_.sub_mkt_data_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.ControlMessage.sub_mkt_data)
}
inline ::financio::trading::SubscribeMarketData* PROTOBUF_NONNULL ControlMessage::_internal_mutable_sub_mkt_data() {
  if (payload_case() != kSubMktData) {
    clear_payload();
    set_has_sub_mkt_data();
    _impl_.payload_.sub_mkt_data_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::SubscribeMarketData>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::SubscribeMarketData*>(_impl_.payload_.sub_mkt_data_);
}
inline ::financio::trading::SubscribeMarketData* PROTOBUF_NONNULL ControlMessage::mutable_sub_mkt_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::SubscribeMarketData* _msg = _internal_mutable_sub_mkt_data();
  // @@protoc_insertion_point(field_mutable:financio.trading.ControlMessage.sub_mkt_data)
  return _msg;
}

// .financio.trading.UnsubscribeMarketData unsub_mkt_data = 12;
inline bool ControlMessage::has_unsub_mkt_data() const {
  return payload_case() == kUnsubMktData;
}
inline bool ControlMessage::_internal_has_unsub_mkt_data() const {
  return payload_case() == kUnsubMktData;
}
inline void ControlMessage::set_has_unsub_mkt_data() {
  _impl_._oneof_case_[0] = kUnsubMktData;
}
inline void ControlMessage::clear_unsub_mkt_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kUnsubMktData) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.unsub_mkt_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.unsub_mkt_data_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::UnsubscribeMarketData* PROTOBUF_NULLABLE ControlMessage::release_unsub_mkt_data() {
  // @@protoc_insertion_point(field_release:financio.trading.ControlMessage.unsub_mkt_data)
  if (payload_case() == kUnsubMktData) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::UnsubscribeMarketData*>(_impl_.payload_.unsub_mkt_data_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.unsub_mkt_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::UnsubscribeMarketData& ControlMessage::_internal_unsub_mkt_data() const {
  return payload_case() == kUnsubMktData ? *reinterpret_cast<::financio::trading::UnsubscribeMarketData*>(_impl_.payload_.unsub_mkt_data_) : reinterpret_cast<::financio::trading::UnsubscribeMarketData&>(::financio::trading::_UnsubscribeMarketData_default_instance_);
}
inline const ::financio::trading::UnsubscribeMarketData& ControlMessage::unsub_mkt_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.unsub_mkt_data)
  return _internal_unsub_mkt_data();
}
inline ::financio::trading::UnsubscribeMarketData* PROTOBUF_NULLABLE ControlMessage::unsafe_arena_release_unsub_mkt_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.ControlMessage.unsub_mkt_data)
  if (payload_case() == kUnsubMktData) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::UnsubscribeMarketData*>(_impl_.payload_.unsub_mkt_data_);
    _impl_.payload_.unsub_mkt_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlMessage::unsafe_arena_set_allocated_unsub_mkt_data(
    ::financio::trading::UnsubscribeMarketData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_unsub_mkt_data();
    _impl_.payload_.unsub_mkt_data_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.ControlMessage.unsub_mkt_data)
}
inline ::financio::trading::UnsubscribeMarketData* PROTOBUF_NONNULL ControlMessage::_internal_mutable_unsub_mkt_data() {
  if (payload_case() != kUnsubMktData) {
    clear_payload();
    set_has_unsub_mkt_data();
    _impl_.payload_.unsub_mkt_data_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::UnsubscribeMarketData>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::UnsubscribeMarketData*>(_impl_.payload_.unsub_mkt_data_);
}
inline ::financio::trading::UnsubscribeMarketData* PROTOBUF_NONNULL ControlMessage::mutable_unsub_mkt_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::UnsubscribeMarketData* _msg = _internal_mutable_unsub_mkt_data();
  // @@protoc_insertion_point(field_mutable:financio.trading.ControlMessage.unsub_mkt_data)
  return _msg;
}

// .financio.trading.PlaceOrder place_order = 13;
inline bool ControlMessage::has_place_order() const {
  return payload_case() == kPlaceOrder;
}
inline bool ControlMessage::_internal_has_place_order() const {
  return payload_case() == kPlaceOrder;
}
inline void ControlMessage::set_has_place_order() {
  _impl_._oneof_case_[0] = kPlaceOrder;
}
inline void ControlMessage::clear_place_order() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPlaceOrder) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.place_order_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.place_order_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::PlaceOrder* PROTOBUF_NULLABLE ControlMessage::release_place_order() {
  // @@protoc_insertion_point(field_release:financio.trading.ControlMessage.place_order)
  if (payload_case() == kPlaceOrder) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::PlaceOrder*>(_impl_.payload_.place_order_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.place_order_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::PlaceOrder& ControlMessage::_internal_place_order() const {
  return payload_case() == kPlaceOrder ? *reinterpret_cast<::financio::trading::PlaceOrder*>(_impl_.payload_.place_order_) : reinterpret_cast<::financio::trading::PlaceOrder&>(::financio::trading::_PlaceOrder_default_instance_);
}
inline const ::financio::trading::PlaceOrder& ControlMessage::place_order() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.place_order)
  return _internal_place_order();
}
inline ::financio::trading::PlaceOrder* PROTOBUF_NULLABLE ControlMessage::unsafe_arena_release_place_order() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.ControlMessage.place_order)
  if (payload_case() == kPlaceOrder) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::PlaceOrder*>(_impl_.payload_.place_order_);
    _impl_.payload_.place_order_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlMessage::unsafe_arena_set_allocated_place_order(
    ::financio::trading::PlaceOrder* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_place_order();
    _impl_.payload_.place_order_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.ControlMessage.place_order)
}
inline ::financio::trading::PlaceOrder* PROTOBUF_NONNULL ControlMessage::_internal_mutable_place_order() {
  if (payload_case() != kPlaceOrder) {
    clear_payload();
    set_has_place_order();
    _impl_.payload_.place_order_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::PlaceOrder>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::PlaceOrder*>(_impl_.payload_.place_order_);
}
inline ::financio::trading::PlaceOrder* PROTOBUF_NONNULL ControlMessage::mutable_place_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::PlaceOrder* _msg = _internal_mutable_place_order();
  // @@protoc_insertion_point(field_mutable:financio.trading.ControlMessage.place_order)
  return _msg;
}

// .financio.trading.CancelOrder cancel_order = 14;
inline bool ControlMessage::has_cancel_order() const {
  return payload_case() == kCancelOrder;
}
inline bool ControlMessage::_internal_has_cancel_order() const {
  return payload_case() == kCancelOrder;
}
inline void ControlMessage::set_has_cancel_order() {
  _impl_._oneof_case_[0] = kCancelOrder;
}
inline void ControlMessage::clear_cancel_order() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kCancelOrder) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.cancel_order_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.cancel_order_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::CancelOrder* PROTOBUF_NULLABLE ControlMessage::release_cancel_order() {
  // @@protoc_insertion_point(field_release:financio.trading.ControlMessage.cancel_order)
  if (payload_case() == kCancelOrder) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::CancelOrder*>(_impl_.payload_.cancel_order_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.cancel_order_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::CancelOrder& ControlMessage::_internal_cancel_order() const {
  return payload_case() == kCancelOrder ? *reinterpret_cast<::financio::trading::CancelOrder*>(_impl_.payload_.cancel_order_) : reinterpret_cast<::financio::trading::CancelOrder&>(::financio::trading::_CancelOrder_default_instance_);
}
inline const ::financio::trading::CancelOrder& ControlMessage::cancel_order() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.cancel_order)
  return _internal_cancel_order();
}
inline ::financio::trading::CancelOrder* PROTOBUF_NULLABLE ControlMessage::unsafe_arena_release_cancel_order() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.ControlMessage.cancel_order)
  if (payload_case() == kCancelOrder) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::CancelOrder*>(_impl_.payload_.cancel_order_);
    _impl_.payload_.cancel_order_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlMessage::unsafe_arena_set_allocated_cancel_order(
    ::financio::trading::CancelOrder* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_cancel_order();
    _impl_.payload_.cancel_order_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.ControlMessage.cancel_order)
}
inline ::financio::trading::CancelOrder* PROTOBUF_NONNULL ControlMessage::_internal_mutable_cancel_order() {
  if (payload_case() != kCancelOrder) {
    clear_payload();
    set_has_cancel_order();
    _impl_.payload_.cancel_order_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::CancelOrder>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::CancelOrder*>(_impl_.payload_.cancel_order_);
}
inline ::financio::trading::CancelOrder* PROTOBUF_NONNULL ControlMessage::mutable_cancel_order()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::CancelOrder* _msg = _internal_mutable_cancel_order();
  // @@protoc_insertion_point(field_mutable:financio.trading.ControlMessage.cancel_order)
  return _msg;
}

// .financio.trading.HistoricalData req_historical_data = 15;
inline bool ControlMessage::has_req_historical_data() const {
  return payload_case() == kReqHistoricalData;
}
inline bool ControlMessage::_internal_has_req_historical_data() const {
  return payload_case() == kReqHistoricalData;
}
inline void ControlMessage::set_has_req_historical_data() {
  _impl_._oneof_case_[0] = kReqHistoricalData;
}
inline void ControlMessage::clear_req_historical_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kReqHistoricalData) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.req_historical_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.req_historical_data_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::HistoricalData* PROTOBUF_NULLABLE ControlMessage::release_req_historical_data() {
  // @@protoc_insertion_point(field_release:financio.trading.ControlMessage.req_historical_data)
  if (payload_case() == kReqHistoricalData) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::HistoricalData*>(_impl_.payload_.req_historical_data_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.req_historical_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::HistoricalData& ControlMessage::_internal_req_historical_data() const {
  return payload_case() == kReqHistoricalData ? *reinterpret_cast<::financio::trading::HistoricalData*>(_impl_.payload_.req_historical_data_) : reinterpret_cast<::financio::trading::HistoricalData&>(::financio::trading::_HistoricalData_default_instance_);
}
inline const ::financio::trading::HistoricalData& ControlMessage::req_historical_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.req_historical_data)
  return _internal_req_historical_data();
}
inline ::financio::trading::HistoricalData* PROTOBUF_NULLABLE ControlMessage::unsafe_arena_release_req_historical_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.ControlMessage.req_historical_data)
  if (payload_case() == kReqHistoricalData) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::HistoricalData*>(_impl_.payload_.req_historical_data_);
    _impl_.payload_.req_historical_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlMessage::unsafe_arena_set_allocated_req_historical_data(
    ::financio::trading::HistoricalData* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_req_historical_data();
    _impl_.payload_.req_historical_data_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.ControlMessage.req_historical_data)
}
inline ::financio::trading::HistoricalData* PROTOBUF_NONNULL ControlMessage::_internal_mutable_req_historical_data() {
  if (payload_case() != kReqHistoricalData) {
    clear_payload();
    set_has_req_historical_data();
    _impl_.payload_.req_historical_data_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::HistoricalData>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::HistoricalData*>(_impl_.payload_.req_historical_data_);
}
inline ::financio::trading::HistoricalData* PROTOBUF_NONNULL ControlMessage::mutable_req_historical_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::HistoricalData* _msg = _internal_mutable_req_historical_data();
  // @@protoc_insertion_point(field_mutable:financio.trading.ControlMessage.req_historical_data)
  return _msg;
}

// .financio.trading.Ping ping = 16;
inline bool ControlMessage::has_ping() const {
  return payload_case() == kPing;
}
inline bool ControlMessage::_internal_has_ping() const {
  return payload_case() == kPing;
}
inline void ControlMessage::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void ControlMessage::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPing) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.ping_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.ping_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::Ping* PROTOBUF_NULLABLE ControlMessage::release_ping() {
  // @@protoc_insertion_point(field_release:financio.trading.ControlMessage.ping)
  if (payload_case() == kPing) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::Ping*>(_impl_.payload_.ping_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::Ping& ControlMessage::_internal_ping() const {
  return payload_case() == kPing ? *reinterpret_cast<::financio::trading::Ping*>(_impl_.payload_.ping_) : reinterpret_cast<::financio::trading::Ping&>(::financio::trading::_Ping_default_instance_);
}
inline const ::financio::trading::Ping& ControlMessage::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.ControlMessage.ping)
  return _internal_ping();
}
inline ::financio::trading::Ping* PROTOBUF_NULLABLE ControlMessage::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.ControlMessage.ping)
  if (payload_case() == kPing) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::Ping*>(_impl_.payload_.ping_);
    _impl_.payload_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlMessage::unsafe_arena_set_allocated_ping(
    ::financio::trading::Ping* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_ping();
    _impl_.payload_.ping_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.ControlMessage.ping)
}
inline ::financio::trading::Ping* PROTOBUF_NONNULL ControlMessage::_internal_mutable_ping() {
  if (payload_case() != kPing) {
    clear_payload();
    set_has_ping();
    _impl_.payload_.ping_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::Ping>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::Ping*>(_impl_.payload_.ping_);
}
inline ::financio::trading::Ping* PROTOBUF_NONNULL ControlMessage::mutable_ping()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::Ping* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:financio.trading.ControlMessage.ping)
  return _msg;
}

inline bool ControlMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ControlMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ControlMessage::PayloadCase ControlMessage::payload_case() const {
  return ControlMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trading
}  // namespace financio


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // trading_2fcontrol_2eproto_2epb_2eh
