// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: trading/state.proto
// Protobuf C++ Version: 6.32.1

#ifndef trading_2fstate_2eproto_2epb_2eh
#define trading_2fstate_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6032001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "trading/common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_trading_2fstate_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_trading_2fstate_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_trading_2fstate_2eproto;
}  // extern "C"
namespace financio {
namespace trading {
class AccountSummary;
struct AccountSummaryDefaultTypeInternal;
extern AccountSummaryDefaultTypeInternal _AccountSummary_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AccountSummary_class_data_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Error_class_data_;
class HistoricalBar;
struct HistoricalBarDefaultTypeInternal;
extern HistoricalBarDefaultTypeInternal _HistoricalBar_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HistoricalBar_class_data_;
class HistoricalEnd;
struct HistoricalEndDefaultTypeInternal;
extern HistoricalEndDefaultTypeInternal _HistoricalEnd_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull HistoricalEnd_class_data_;
class NewsHeadline;
struct NewsHeadlineDefaultTypeInternal;
extern NewsHeadlineDefaultTypeInternal _NewsHeadline_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NewsHeadline_class_data_;
class OrderFill;
struct OrderFillDefaultTypeInternal;
extern OrderFillDefaultTypeInternal _OrderFill_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OrderFill_class_data_;
class OrderStatus;
struct OrderStatusDefaultTypeInternal;
extern OrderStatusDefaultTypeInternal _OrderStatus_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull OrderStatus_class_data_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Pong_class_data_;
class PortfolioPosition;
struct PortfolioPositionDefaultTypeInternal;
extern PortfolioPositionDefaultTypeInternal _PortfolioPosition_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PortfolioPosition_class_data_;
class StateMessage;
struct StateMessageDefaultTypeInternal;
extern StateMessageDefaultTypeInternal _StateMessage_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull StateMessage_class_data_;
class TickPrice;
struct TickPriceDefaultTypeInternal;
extern TickPriceDefaultTypeInternal _TickPrice_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TickPrice_class_data_;
class TickSize;
struct TickSizeDefaultTypeInternal;
extern TickSizeDefaultTypeInternal _TickSize_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TickSize_class_data_;
}  // namespace trading
}  // namespace financio
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace financio {
namespace trading {

// ===================================================================


// -------------------------------------------------------------------

class TickSize final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.TickSize) */ {
 public:
  inline TickSize() : TickSize(nullptr) {}
  ~TickSize() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TickSize* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TickSize));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TickSize(::google::protobuf::internal::ConstantInitialized);

  inline TickSize(const TickSize& from) : TickSize(nullptr, from) {}
  inline TickSize(TickSize&& from) noexcept
      : TickSize(nullptr, ::std::move(from)) {}
  inline TickSize& operator=(const TickSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickSize& operator=(TickSize&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickSize& default_instance() {
    return *reinterpret_cast<const TickSize*>(
        &_TickSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TickSize& a, TickSize& b) { a.Swap(&b); }
  inline void Swap(TickSize* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickSize* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickSize* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TickSize>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TickSize& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TickSize& from) { TickSize::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TickSize* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.TickSize"; }

 protected:
  explicit TickSize(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TickSize(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TickSize& from);
  TickSize(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TickSize&& from) noexcept
      : TickSize(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSizeFieldNumber = 2,
    kFieldFieldNumber = 1,
  };
  // double size = 2;
  void clear_size() ;
  double size() const;
  void set_size(double value);

  private:
  double _internal_size() const;
  void _internal_set_size(double value);

  public:
  // int32 field = 1;
  void clear_field() ;
  ::int32_t field() const;
  void set_field(::int32_t value);

  private:
  ::int32_t _internal_field() const;
  void _internal_set_field(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.TickSize)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TickSize& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    double size_;
    ::int32_t field_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TickSize_class_data_;
// -------------------------------------------------------------------

class PortfolioPosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.PortfolioPosition) */ {
 public:
  inline PortfolioPosition() : PortfolioPosition(nullptr) {}
  ~PortfolioPosition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PortfolioPosition* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PortfolioPosition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PortfolioPosition(::google::protobuf::internal::ConstantInitialized);

  inline PortfolioPosition(const PortfolioPosition& from) : PortfolioPosition(nullptr, from) {}
  inline PortfolioPosition(PortfolioPosition&& from) noexcept
      : PortfolioPosition(nullptr, ::std::move(from)) {}
  inline PortfolioPosition& operator=(const PortfolioPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortfolioPosition& operator=(PortfolioPosition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortfolioPosition& default_instance() {
    return *reinterpret_cast<const PortfolioPosition*>(
        &_PortfolioPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(PortfolioPosition& a, PortfolioPosition& b) { a.Swap(&b); }
  inline void Swap(PortfolioPosition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortfolioPosition* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortfolioPosition* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PortfolioPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PortfolioPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PortfolioPosition& from) { PortfolioPosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PortfolioPosition* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.PortfolioPosition"; }

 protected:
  explicit PortfolioPosition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PortfolioPosition(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PortfolioPosition& from);
  PortfolioPosition(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PortfolioPosition&& from) noexcept
      : PortfolioPosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kPositionFieldNumber = 3,
    kAvgCostFieldNumber = 4,
  };
  // string account = 1;
  void clear_account() ;
  const ::std::string& account() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_account();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_account();
  void set_allocated_account(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_account() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_account(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_account();

  public:
  // string symbol = 2;
  void clear_symbol() ;
  const ::std::string& symbol() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_symbol(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_symbol();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_symbol();
  void set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_symbol() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_symbol();

  public:
  // double position = 3;
  void clear_position() ;
  double position() const;
  void set_position(double value);

  private:
  double _internal_position() const;
  void _internal_set_position(double value);

  public:
  // double avg_cost = 4;
  void clear_avg_cost() ;
  double avg_cost() const;
  void set_avg_cost(double value);

  private:
  double _internal_avg_cost() const;
  void _internal_set_avg_cost(double value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.PortfolioPosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PortfolioPosition& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::google::protobuf::internal::ArenaStringPtr symbol_;
    double position_;
    double avg_cost_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PortfolioPosition_class_data_;
// -------------------------------------------------------------------

class Pong final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pong* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pong));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pong(::google::protobuf::internal::ConstantInitialized);

  inline Pong(const Pong& from) : Pong(nullptr, from) {}
  inline Pong(Pong&& from) noexcept
      : Pong(nullptr, ::std::move(from)) {}
  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *reinterpret_cast<const Pong*>(
        &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Pong& a, Pong& b) { a.Swap(&b); }
  inline void Swap(Pong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Pong>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pong& from) { Pong::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Pong* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.Pong"; }

 protected:
  explicit Pong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Pong(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Pong& from);
  Pong(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Pong&& from) noexcept
      : Pong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNoteFieldNumber = 1,
  };
  // string note = 1;
  void clear_note() ;
  const ::std::string& note() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_note(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_note();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_note();
  void set_allocated_note(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_note() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_note(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_note();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.Pong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 34,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Pong& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr note_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Pong_class_data_;
// -------------------------------------------------------------------

class OrderStatus final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.OrderStatus) */ {
 public:
  inline OrderStatus() : OrderStatus(nullptr) {}
  ~OrderStatus() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OrderStatus* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OrderStatus));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrderStatus(::google::protobuf::internal::ConstantInitialized);

  inline OrderStatus(const OrderStatus& from) : OrderStatus(nullptr, from) {}
  inline OrderStatus(OrderStatus&& from) noexcept
      : OrderStatus(nullptr, ::std::move(from)) {}
  inline OrderStatus& operator=(const OrderStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderStatus& operator=(OrderStatus&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderStatus& default_instance() {
    return *reinterpret_cast<const OrderStatus*>(
        &_OrderStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(OrderStatus& a, OrderStatus& b) { a.Swap(&b); }
  inline void Swap(OrderStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderStatus* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderStatus* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OrderStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrderStatus& from) { OrderStatus::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OrderStatus* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.OrderStatus"; }

 protected:
  explicit OrderStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OrderStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OrderStatus& from);
  OrderStatus(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OrderStatus&& from) noexcept
      : OrderStatus(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatusFieldNumber = 1,
    kFilledFieldNumber = 2,
    kRemainingFieldNumber = 3,
    kAvgFillPxFieldNumber = 4,
  };
  // string status = 1;
  void clear_status() ;
  const ::std::string& status() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_status();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_status();
  void set_allocated_status(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_status() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_status(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_status();

  public:
  // double filled = 2;
  void clear_filled() ;
  double filled() const;
  void set_filled(double value);

  private:
  double _internal_filled() const;
  void _internal_set_filled(double value);

  public:
  // double remaining = 3;
  void clear_remaining() ;
  double remaining() const;
  void set_remaining(double value);

  private:
  double _internal_remaining() const;
  void _internal_set_remaining(double value);

  public:
  // double avg_fill_px = 4;
  void clear_avg_fill_px() ;
  double avg_fill_px() const;
  void set_avg_fill_px(double value);

  private:
  double _internal_avg_fill_px() const;
  void _internal_set_avg_fill_px(double value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.OrderStatus)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 43,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OrderStatus& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    double filled_;
    double remaining_;
    double avg_fill_px_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OrderStatus_class_data_;
// -------------------------------------------------------------------

class NewsHeadline final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.NewsHeadline) */ {
 public:
  inline NewsHeadline() : NewsHeadline(nullptr) {}
  ~NewsHeadline() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NewsHeadline* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NewsHeadline));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NewsHeadline(::google::protobuf::internal::ConstantInitialized);

  inline NewsHeadline(const NewsHeadline& from) : NewsHeadline(nullptr, from) {}
  inline NewsHeadline(NewsHeadline&& from) noexcept
      : NewsHeadline(nullptr, ::std::move(from)) {}
  inline NewsHeadline& operator=(const NewsHeadline& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewsHeadline& operator=(NewsHeadline&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewsHeadline& default_instance() {
    return *reinterpret_cast<const NewsHeadline*>(
        &_NewsHeadline_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(NewsHeadline& a, NewsHeadline& b) { a.Swap(&b); }
  inline void Swap(NewsHeadline* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewsHeadline* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewsHeadline* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NewsHeadline>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NewsHeadline& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NewsHeadline& from) { NewsHeadline::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NewsHeadline* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.NewsHeadline"; }

 protected:
  explicit NewsHeadline(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NewsHeadline(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NewsHeadline& from);
  NewsHeadline(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NewsHeadline&& from) noexcept
      : NewsHeadline(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProviderFieldNumber = 1,
    kHeadlineFieldNumber = 2,
  };
  // string provider = 1;
  void clear_provider() ;
  const ::std::string& provider() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_provider(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_provider();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_provider();
  void set_allocated_provider(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_provider() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_provider(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_provider();

  public:
  // string headline = 2;
  void clear_headline() ;
  const ::std::string& headline() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_headline(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_headline();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_headline();
  void set_allocated_headline(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_headline() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_headline(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_headline();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.NewsHeadline)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 54,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NewsHeadline& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr provider_;
    ::google::protobuf::internal::ArenaStringPtr headline_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NewsHeadline_class_data_;
// -------------------------------------------------------------------

class HistoricalEnd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.HistoricalEnd) */ {
 public:
  inline HistoricalEnd() : HistoricalEnd(nullptr) {}
  ~HistoricalEnd() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HistoricalEnd* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HistoricalEnd));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HistoricalEnd(::google::protobuf::internal::ConstantInitialized);

  inline HistoricalEnd(const HistoricalEnd& from) : HistoricalEnd(nullptr, from) {}
  inline HistoricalEnd(HistoricalEnd&& from) noexcept
      : HistoricalEnd(nullptr, ::std::move(from)) {}
  inline HistoricalEnd& operator=(const HistoricalEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoricalEnd& operator=(HistoricalEnd&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoricalEnd& default_instance() {
    return *reinterpret_cast<const HistoricalEnd*>(
        &_HistoricalEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(HistoricalEnd& a, HistoricalEnd& b) { a.Swap(&b); }
  inline void Swap(HistoricalEnd* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoricalEnd* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoricalEnd* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HistoricalEnd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HistoricalEnd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HistoricalEnd& from) { HistoricalEnd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HistoricalEnd* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.HistoricalEnd"; }

 protected:
  explicit HistoricalEnd(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HistoricalEnd(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HistoricalEnd& from);
  HistoricalEnd(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HistoricalEnd&& from) noexcept
      : HistoricalEnd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // string start = 1;
  void clear_start() ;
  const ::std::string& start() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_start(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_start();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_start();
  void set_allocated_start(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_start() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_start(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_start();

  public:
  // string end = 2;
  void clear_end() ;
  const ::std::string& end() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_end(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_end();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_end();
  void set_allocated_end(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_end() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_end(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_end();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.HistoricalEnd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 47,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HistoricalEnd& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr start_;
    ::google::protobuf::internal::ArenaStringPtr end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HistoricalEnd_class_data_;
// -------------------------------------------------------------------

class Error final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Error* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Error));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Error(::google::protobuf::internal::ConstantInitialized);

  inline Error(const Error& from) : Error(nullptr, from) {}
  inline Error(Error&& from) noexcept
      : Error(nullptr, ::std::move(from)) {}
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *reinterpret_cast<const Error*>(
        &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Error& a, Error& b) { a.Swap(&b); }
  inline void Swap(Error* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Error>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Error& from) { Error::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Error* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.Error"; }

 protected:
  explicit Error(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Error(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Error& from);
  Error(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Error&& from) noexcept
      : Error(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const ::std::string& message() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_message();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_message();
  void set_allocated_message(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_message() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_message(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_message();

  public:
  // int32 code = 1;
  void clear_code() ;
  ::int32_t code() const;
  void set_code(::int32_t value);

  private:
  ::int32_t _internal_code() const;
  void _internal_set_code(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.Error)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 38,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Error& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::int32_t code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Error_class_data_;
// -------------------------------------------------------------------

class AccountSummary final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.AccountSummary) */ {
 public:
  inline AccountSummary() : AccountSummary(nullptr) {}
  ~AccountSummary() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AccountSummary* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AccountSummary));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AccountSummary(::google::protobuf::internal::ConstantInitialized);

  inline AccountSummary(const AccountSummary& from) : AccountSummary(nullptr, from) {}
  inline AccountSummary(AccountSummary&& from) noexcept
      : AccountSummary(nullptr, ::std::move(from)) {}
  inline AccountSummary& operator=(const AccountSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountSummary& operator=(AccountSummary&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountSummary& default_instance() {
    return *reinterpret_cast<const AccountSummary*>(
        &_AccountSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AccountSummary& a, AccountSummary& b) { a.Swap(&b); }
  inline void Swap(AccountSummary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountSummary* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountSummary* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AccountSummary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AccountSummary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AccountSummary& from) { AccountSummary::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AccountSummary* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.AccountSummary"; }

 protected:
  explicit AccountSummary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AccountSummary(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AccountSummary& from);
  AccountSummary(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AccountSummary&& from) noexcept
      : AccountSummary(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 1,
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kCurrencyFieldNumber = 4,
  };
  // string account = 1;
  void clear_account() ;
  const ::std::string& account() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_account();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_account();
  void set_allocated_account(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_account() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_account(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_account();

  public:
  // string key = 2;
  void clear_key() ;
  const ::std::string& key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_key();
  void set_allocated_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_key();

  public:
  // string value = 3;
  void clear_value() ;
  const ::std::string& value() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_value();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_value();
  void set_allocated_value(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_value() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_value(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_value();

  public:
  // string currency = 4;
  void clear_currency() ;
  const ::std::string& currency() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_currency(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_currency();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_currency();
  void set_allocated_currency(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_currency() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_currency();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.AccountSummary)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 63,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AccountSummary& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::google::protobuf::internal::ArenaStringPtr currency_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AccountSummary_class_data_;
// -------------------------------------------------------------------

class TickPrice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.TickPrice) */ {
 public:
  inline TickPrice() : TickPrice(nullptr) {}
  ~TickPrice() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TickPrice* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TickPrice));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TickPrice(::google::protobuf::internal::ConstantInitialized);

  inline TickPrice(const TickPrice& from) : TickPrice(nullptr, from) {}
  inline TickPrice(TickPrice&& from) noexcept
      : TickPrice(nullptr, ::std::move(from)) {}
  inline TickPrice& operator=(const TickPrice& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickPrice& operator=(TickPrice&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickPrice& default_instance() {
    return *reinterpret_cast<const TickPrice*>(
        &_TickPrice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(TickPrice& a, TickPrice& b) { a.Swap(&b); }
  inline void Swap(TickPrice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickPrice* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickPrice* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TickPrice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TickPrice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TickPrice& from) { TickPrice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TickPrice* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.TickPrice"; }

 protected:
  explicit TickPrice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TickPrice(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TickPrice& from);
  TickPrice(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TickPrice&& from) noexcept
      : TickPrice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAttribFieldNumber = 3,
    kPriceFieldNumber = 1,
    kFieldFieldNumber = 2,
  };
  // .financio.trading.TickAttribPB attrib = 3;
  bool has_attrib() const;
  void clear_attrib() ;
  const ::financio::trading::TickAttribPB& attrib() const;
  [[nodiscard]] ::financio::trading::TickAttribPB* PROTOBUF_NULLABLE release_attrib();
  ::financio::trading::TickAttribPB* PROTOBUF_NONNULL mutable_attrib();
  void set_allocated_attrib(::financio::trading::TickAttribPB* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_attrib(::financio::trading::TickAttribPB* PROTOBUF_NULLABLE value);
  ::financio::trading::TickAttribPB* PROTOBUF_NULLABLE unsafe_arena_release_attrib();

  private:
  const ::financio::trading::TickAttribPB& _internal_attrib() const;
  ::financio::trading::TickAttribPB* PROTOBUF_NONNULL _internal_mutable_attrib();

  public:
  // double price = 1;
  void clear_price() ;
  double price() const;
  void set_price(double value);

  private:
  double _internal_price() const;
  void _internal_set_price(double value);

  public:
  // int32 field = 2;
  void clear_field() ;
  ::int32_t field() const;
  void set_field(::int32_t value);

  private:
  ::int32_t _internal_field() const;
  void _internal_set_field(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.TickPrice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TickPrice& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::financio::trading::TickAttribPB* PROTOBUF_NULLABLE attrib_;
    double price_;
    ::int32_t field_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TickPrice_class_data_;
// -------------------------------------------------------------------

class OrderFill final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.OrderFill) */ {
 public:
  inline OrderFill() : OrderFill(nullptr) {}
  ~OrderFill() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OrderFill* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OrderFill));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OrderFill(::google::protobuf::internal::ConstantInitialized);

  inline OrderFill(const OrderFill& from) : OrderFill(nullptr, from) {}
  inline OrderFill(OrderFill&& from) noexcept
      : OrderFill(nullptr, ::std::move(from)) {}
  inline OrderFill& operator=(const OrderFill& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderFill& operator=(OrderFill&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderFill& default_instance() {
    return *reinterpret_cast<const OrderFill*>(
        &_OrderFill_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(OrderFill& a, OrderFill& b) { a.Swap(&b); }
  inline void Swap(OrderFill* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderFill* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderFill* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OrderFill>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrderFill& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OrderFill& from) { OrderFill::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OrderFill* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.OrderFill"; }

 protected:
  explicit OrderFill(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OrderFill(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OrderFill& from);
  OrderFill(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OrderFill&& from) noexcept
      : OrderFill(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExecFieldNumber = 1,
  };
  // .financio.trading.ExecutionPB exec = 1;
  bool has_exec() const;
  void clear_exec() ;
  const ::financio::trading::ExecutionPB& exec() const;
  [[nodiscard]] ::financio::trading::ExecutionPB* PROTOBUF_NULLABLE release_exec();
  ::financio::trading::ExecutionPB* PROTOBUF_NONNULL mutable_exec();
  void set_allocated_exec(::financio::trading::ExecutionPB* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_exec(::financio::trading::ExecutionPB* PROTOBUF_NULLABLE value);
  ::financio::trading::ExecutionPB* PROTOBUF_NULLABLE unsafe_arena_release_exec();

  private:
  const ::financio::trading::ExecutionPB& _internal_exec() const;
  ::financio::trading::ExecutionPB* PROTOBUF_NONNULL _internal_mutable_exec();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.OrderFill)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OrderFill& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::financio::trading::ExecutionPB* PROTOBUF_NULLABLE exec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull OrderFill_class_data_;
// -------------------------------------------------------------------

class HistoricalBar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.HistoricalBar) */ {
 public:
  inline HistoricalBar() : HistoricalBar(nullptr) {}
  ~HistoricalBar() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HistoricalBar* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HistoricalBar));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HistoricalBar(::google::protobuf::internal::ConstantInitialized);

  inline HistoricalBar(const HistoricalBar& from) : HistoricalBar(nullptr, from) {}
  inline HistoricalBar(HistoricalBar&& from) noexcept
      : HistoricalBar(nullptr, ::std::move(from)) {}
  inline HistoricalBar& operator=(const HistoricalBar& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoricalBar& operator=(HistoricalBar&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HistoricalBar& default_instance() {
    return *reinterpret_cast<const HistoricalBar*>(
        &_HistoricalBar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(HistoricalBar& a, HistoricalBar& b) { a.Swap(&b); }
  inline void Swap(HistoricalBar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoricalBar* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HistoricalBar* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HistoricalBar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HistoricalBar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HistoricalBar& from) { HistoricalBar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HistoricalBar* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.HistoricalBar"; }

 protected:
  explicit HistoricalBar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  HistoricalBar(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const HistoricalBar& from);
  HistoricalBar(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, HistoricalBar&& from) noexcept
      : HistoricalBar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBarFieldNumber = 1,
  };
  // .financio.trading.BarPB bar = 1;
  bool has_bar() const;
  void clear_bar() ;
  const ::financio::trading::BarPB& bar() const;
  [[nodiscard]] ::financio::trading::BarPB* PROTOBUF_NULLABLE release_bar();
  ::financio::trading::BarPB* PROTOBUF_NONNULL mutable_bar();
  void set_allocated_bar(::financio::trading::BarPB* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bar(::financio::trading::BarPB* PROTOBUF_NULLABLE value);
  ::financio::trading::BarPB* PROTOBUF_NULLABLE unsafe_arena_release_bar();

  private:
  const ::financio::trading::BarPB& _internal_bar() const;
  ::financio::trading::BarPB* PROTOBUF_NONNULL _internal_mutable_bar();

  public:
  // @@protoc_insertion_point(class_scope:financio.trading.HistoricalBar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const HistoricalBar& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::financio::trading::BarPB* PROTOBUF_NULLABLE bar_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull HistoricalBar_class_data_;
// -------------------------------------------------------------------

class StateMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:financio.trading.StateMessage) */ {
 public:
  inline StateMessage() : StateMessage(nullptr) {}
  ~StateMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StateMessage* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StateMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StateMessage(::google::protobuf::internal::ConstantInitialized);

  inline StateMessage(const StateMessage& from) : StateMessage(nullptr, from) {}
  inline StateMessage(StateMessage&& from) noexcept
      : StateMessage(nullptr, ::std::move(from)) {}
  inline StateMessage& operator=(const StateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateMessage& operator=(StateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateMessage& default_instance() {
    return *reinterpret_cast<const StateMessage*>(
        &_StateMessage_default_instance_);
  }
  enum PayloadCase {
    kError = 10,
    kTickPrice = 11,
    kTickSize = 12,
    kOrderStatus = 13,
    kOrderFilled = 14,
    kHistBar = 20,
    kHistEnd = 21,
    kAccountSummary = 30,
    kPortfolioUpdate = 31,
    kNewsHeadline = 32,
    kPong = 40,
    PAYLOAD_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(StateMessage& a, StateMessage& b) { a.Swap(&b); }
  inline void Swap(StateMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateMessage* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateMessage* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StateMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StateMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StateMessage& from) { StateMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StateMessage* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "financio.trading.StateMessage"; }

 protected:
  explicit StateMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  StateMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const StateMessage& from);
  StateMessage(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, StateMessage&& from) noexcept
      : StateMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTsFieldNumber = 3,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 1,
    kErrorFieldNumber = 10,
    kTickPriceFieldNumber = 11,
    kTickSizeFieldNumber = 12,
    kOrderStatusFieldNumber = 13,
    kOrderFilledFieldNumber = 14,
    kHistBarFieldNumber = 20,
    kHistEndFieldNumber = 21,
    kAccountSummaryFieldNumber = 30,
    kPortfolioUpdateFieldNumber = 31,
    kNewsHeadlineFieldNumber = 32,
    kPongFieldNumber = 40,
  };
  // .google.protobuf.Timestamp ts = 3;
  bool has_ts() const;
  void clear_ts() ;
  const ::google::protobuf::Timestamp& ts() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_ts();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_ts();
  void set_allocated_ts(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ts(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_ts();

  private:
  const ::google::protobuf::Timestamp& _internal_ts() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_ts();

  public:
  // int64 id = 2;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // .financio.trading.StateType type = 1;
  void clear_type() ;
  ::financio::trading::StateType type() const;
  void set_type(::financio::trading::StateType value);

  private:
  ::financio::trading::StateType _internal_type() const;
  void _internal_set_type(::financio::trading::StateType value);

  public:
  // .financio.trading.Error error = 10;
  bool has_error() const;
  private:
  bool _internal_has_error() const;

  public:
  void clear_error() ;
  const ::financio::trading::Error& error() const;
  [[nodiscard]] ::financio::trading::Error* PROTOBUF_NULLABLE release_error();
  ::financio::trading::Error* PROTOBUF_NONNULL mutable_error();
  void set_allocated_error(::financio::trading::Error* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_error(::financio::trading::Error* PROTOBUF_NULLABLE value);
  ::financio::trading::Error* PROTOBUF_NULLABLE unsafe_arena_release_error();

  private:
  const ::financio::trading::Error& _internal_error() const;
  ::financio::trading::Error* PROTOBUF_NONNULL _internal_mutable_error();

  public:
  // .financio.trading.TickPrice tick_price = 11;
  bool has_tick_price() const;
  private:
  bool _internal_has_tick_price() const;

  public:
  void clear_tick_price() ;
  const ::financio::trading::TickPrice& tick_price() const;
  [[nodiscard]] ::financio::trading::TickPrice* PROTOBUF_NULLABLE release_tick_price();
  ::financio::trading::TickPrice* PROTOBUF_NONNULL mutable_tick_price();
  void set_allocated_tick_price(::financio::trading::TickPrice* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tick_price(::financio::trading::TickPrice* PROTOBUF_NULLABLE value);
  ::financio::trading::TickPrice* PROTOBUF_NULLABLE unsafe_arena_release_tick_price();

  private:
  const ::financio::trading::TickPrice& _internal_tick_price() const;
  ::financio::trading::TickPrice* PROTOBUF_NONNULL _internal_mutable_tick_price();

  public:
  // .financio.trading.TickSize tick_size = 12;
  bool has_tick_size() const;
  private:
  bool _internal_has_tick_size() const;

  public:
  void clear_tick_size() ;
  const ::financio::trading::TickSize& tick_size() const;
  [[nodiscard]] ::financio::trading::TickSize* PROTOBUF_NULLABLE release_tick_size();
  ::financio::trading::TickSize* PROTOBUF_NONNULL mutable_tick_size();
  void set_allocated_tick_size(::financio::trading::TickSize* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_tick_size(::financio::trading::TickSize* PROTOBUF_NULLABLE value);
  ::financio::trading::TickSize* PROTOBUF_NULLABLE unsafe_arena_release_tick_size();

  private:
  const ::financio::trading::TickSize& _internal_tick_size() const;
  ::financio::trading::TickSize* PROTOBUF_NONNULL _internal_mutable_tick_size();

  public:
  // .financio.trading.OrderStatus order_status = 13;
  bool has_order_status() const;
  private:
  bool _internal_has_order_status() const;

  public:
  void clear_order_status() ;
  const ::financio::trading::OrderStatus& order_status() const;
  [[nodiscard]] ::financio::trading::OrderStatus* PROTOBUF_NULLABLE release_order_status();
  ::financio::trading::OrderStatus* PROTOBUF_NONNULL mutable_order_status();
  void set_allocated_order_status(::financio::trading::OrderStatus* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_status(::financio::trading::OrderStatus* PROTOBUF_NULLABLE value);
  ::financio::trading::OrderStatus* PROTOBUF_NULLABLE unsafe_arena_release_order_status();

  private:
  const ::financio::trading::OrderStatus& _internal_order_status() const;
  ::financio::trading::OrderStatus* PROTOBUF_NONNULL _internal_mutable_order_status();

  public:
  // .financio.trading.OrderFill order_filled = 14;
  bool has_order_filled() const;
  private:
  bool _internal_has_order_filled() const;

  public:
  void clear_order_filled() ;
  const ::financio::trading::OrderFill& order_filled() const;
  [[nodiscard]] ::financio::trading::OrderFill* PROTOBUF_NULLABLE release_order_filled();
  ::financio::trading::OrderFill* PROTOBUF_NONNULL mutable_order_filled();
  void set_allocated_order_filled(::financio::trading::OrderFill* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_order_filled(::financio::trading::OrderFill* PROTOBUF_NULLABLE value);
  ::financio::trading::OrderFill* PROTOBUF_NULLABLE unsafe_arena_release_order_filled();

  private:
  const ::financio::trading::OrderFill& _internal_order_filled() const;
  ::financio::trading::OrderFill* PROTOBUF_NONNULL _internal_mutable_order_filled();

  public:
  // .financio.trading.HistoricalBar hist_bar = 20;
  bool has_hist_bar() const;
  private:
  bool _internal_has_hist_bar() const;

  public:
  void clear_hist_bar() ;
  const ::financio::trading::HistoricalBar& hist_bar() const;
  [[nodiscard]] ::financio::trading::HistoricalBar* PROTOBUF_NULLABLE release_hist_bar();
  ::financio::trading::HistoricalBar* PROTOBUF_NONNULL mutable_hist_bar();
  void set_allocated_hist_bar(::financio::trading::HistoricalBar* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hist_bar(::financio::trading::HistoricalBar* PROTOBUF_NULLABLE value);
  ::financio::trading::HistoricalBar* PROTOBUF_NULLABLE unsafe_arena_release_hist_bar();

  private:
  const ::financio::trading::HistoricalBar& _internal_hist_bar() const;
  ::financio::trading::HistoricalBar* PROTOBUF_NONNULL _internal_mutable_hist_bar();

  public:
  // .financio.trading.HistoricalEnd hist_end = 21;
  bool has_hist_end() const;
  private:
  bool _internal_has_hist_end() const;

  public:
  void clear_hist_end() ;
  const ::financio::trading::HistoricalEnd& hist_end() const;
  [[nodiscard]] ::financio::trading::HistoricalEnd* PROTOBUF_NULLABLE release_hist_end();
  ::financio::trading::HistoricalEnd* PROTOBUF_NONNULL mutable_hist_end();
  void set_allocated_hist_end(::financio::trading::HistoricalEnd* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_hist_end(::financio::trading::HistoricalEnd* PROTOBUF_NULLABLE value);
  ::financio::trading::HistoricalEnd* PROTOBUF_NULLABLE unsafe_arena_release_hist_end();

  private:
  const ::financio::trading::HistoricalEnd& _internal_hist_end() const;
  ::financio::trading::HistoricalEnd* PROTOBUF_NONNULL _internal_mutable_hist_end();

  public:
  // .financio.trading.AccountSummary account_summary = 30;
  bool has_account_summary() const;
  private:
  bool _internal_has_account_summary() const;

  public:
  void clear_account_summary() ;
  const ::financio::trading::AccountSummary& account_summary() const;
  [[nodiscard]] ::financio::trading::AccountSummary* PROTOBUF_NULLABLE release_account_summary();
  ::financio::trading::AccountSummary* PROTOBUF_NONNULL mutable_account_summary();
  void set_allocated_account_summary(::financio::trading::AccountSummary* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_account_summary(::financio::trading::AccountSummary* PROTOBUF_NULLABLE value);
  ::financio::trading::AccountSummary* PROTOBUF_NULLABLE unsafe_arena_release_account_summary();

  private:
  const ::financio::trading::AccountSummary& _internal_account_summary() const;
  ::financio::trading::AccountSummary* PROTOBUF_NONNULL _internal_mutable_account_summary();

  public:
  // .financio.trading.PortfolioPosition portfolio_update = 31;
  bool has_portfolio_update() const;
  private:
  bool _internal_has_portfolio_update() const;

  public:
  void clear_portfolio_update() ;
  const ::financio::trading::PortfolioPosition& portfolio_update() const;
  [[nodiscard]] ::financio::trading::PortfolioPosition* PROTOBUF_NULLABLE release_portfolio_update();
  ::financio::trading::PortfolioPosition* PROTOBUF_NONNULL mutable_portfolio_update();
  void set_allocated_portfolio_update(::financio::trading::PortfolioPosition* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_portfolio_update(::financio::trading::PortfolioPosition* PROTOBUF_NULLABLE value);
  ::financio::trading::PortfolioPosition* PROTOBUF_NULLABLE unsafe_arena_release_portfolio_update();

  private:
  const ::financio::trading::PortfolioPosition& _internal_portfolio_update() const;
  ::financio::trading::PortfolioPosition* PROTOBUF_NONNULL _internal_mutable_portfolio_update();

  public:
  // .financio.trading.NewsHeadline news_headline = 32;
  bool has_news_headline() const;
  private:
  bool _internal_has_news_headline() const;

  public:
  void clear_news_headline() ;
  const ::financio::trading::NewsHeadline& news_headline() const;
  [[nodiscard]] ::financio::trading::NewsHeadline* PROTOBUF_NULLABLE release_news_headline();
  ::financio::trading::NewsHeadline* PROTOBUF_NONNULL mutable_news_headline();
  void set_allocated_news_headline(::financio::trading::NewsHeadline* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_news_headline(::financio::trading::NewsHeadline* PROTOBUF_NULLABLE value);
  ::financio::trading::NewsHeadline* PROTOBUF_NULLABLE unsafe_arena_release_news_headline();

  private:
  const ::financio::trading::NewsHeadline& _internal_news_headline() const;
  ::financio::trading::NewsHeadline* PROTOBUF_NONNULL _internal_mutable_news_headline();

  public:
  // .financio.trading.Pong pong = 40;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;

  public:
  void clear_pong() ;
  const ::financio::trading::Pong& pong() const;
  [[nodiscard]] ::financio::trading::Pong* PROTOBUF_NULLABLE release_pong();
  ::financio::trading::Pong* PROTOBUF_NONNULL mutable_pong();
  void set_allocated_pong(::financio::trading::Pong* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pong(::financio::trading::Pong* PROTOBUF_NULLABLE value);
  ::financio::trading::Pong* PROTOBUF_NULLABLE unsafe_arena_release_pong();

  private:
  const ::financio::trading::Pong& _internal_pong() const;
  ::financio::trading::Pong* PROTOBUF_NONNULL _internal_mutable_pong();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:financio.trading.StateMessage)
 private:
  class _Internal;
  void set_has_error();
  void set_has_tick_price();
  void set_has_tick_size();
  void set_has_order_status();
  void set_has_order_filled();
  void set_has_hist_bar();
  void set_has_hist_end();
  void set_has_account_summary();
  void set_has_portfolio_update();
  void set_has_news_headline();
  void set_has_pong();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 14,
                                   12, 0,
                                   7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const StateMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE ts_;
    ::int64_t id_;
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE error_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE tick_price_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE tick_size_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_status_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE order_filled_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE hist_bar_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE hist_end_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE account_summary_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE portfolio_update_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE news_headline_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE pong_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_trading_2fstate_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull StateMessage_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Error

// int32 code = 1;
inline void Error::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::int32_t Error::code() const {
  // @@protoc_insertion_point(field_get:financio.trading.Error.code)
  return _internal_code();
}
inline void Error::set_code(::int32_t value) {
  _internal_set_code(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:financio.trading.Error.code)
}
inline ::int32_t Error::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_;
}
inline void Error::_internal_set_code(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = value;
}

// string message = 2;
inline void Error::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& Error::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.Error.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Error::set_message(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.Error.message)
}
inline ::std::string* PROTOBUF_NONNULL Error::mutable_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:financio.trading.Error.message)
  return _s;
}
inline const ::std::string& Error::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.message_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Error::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.message_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Error::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.Error.message)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.message_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.message_.Set("", GetArena());
  }
  return released;
}
inline void Error::set_allocated_message(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.Error.message)
}

// -------------------------------------------------------------------

// TickPrice

// double price = 1;
inline void TickPrice::clear_price() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline double TickPrice::price() const {
  // @@protoc_insertion_point(field_get:financio.trading.TickPrice.price)
  return _internal_price();
}
inline void TickPrice::set_price(double value) {
  _internal_set_price(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:financio.trading.TickPrice.price)
}
inline double TickPrice::_internal_price() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.price_;
}
inline void TickPrice::_internal_set_price(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.price_ = value;
}

// int32 field = 2;
inline void TickPrice::clear_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::int32_t TickPrice::field() const {
  // @@protoc_insertion_point(field_get:financio.trading.TickPrice.field)
  return _internal_field();
}
inline void TickPrice::set_field(::int32_t value) {
  _internal_set_field(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:financio.trading.TickPrice.field)
}
inline ::int32_t TickPrice::_internal_field() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_;
}
inline void TickPrice::_internal_set_field(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = value;
}

// .financio.trading.TickAttribPB attrib = 3;
inline bool TickPrice::has_attrib() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attrib_ != nullptr);
  return value;
}
inline const ::financio::trading::TickAttribPB& TickPrice::_internal_attrib() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::financio::trading::TickAttribPB* p = _impl_.attrib_;
  return p != nullptr ? *p : reinterpret_cast<const ::financio::trading::TickAttribPB&>(::financio::trading::_TickAttribPB_default_instance_);
}
inline const ::financio::trading::TickAttribPB& TickPrice::attrib() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.TickPrice.attrib)
  return _internal_attrib();
}
inline void TickPrice::unsafe_arena_set_allocated_attrib(
    ::financio::trading::TickAttribPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attrib_);
  }
  _impl_.attrib_ = reinterpret_cast<::financio::trading::TickAttribPB*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.TickPrice.attrib)
}
inline ::financio::trading::TickAttribPB* PROTOBUF_NULLABLE TickPrice::release_attrib() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::financio::trading::TickAttribPB* released = _impl_.attrib_;
  _impl_.attrib_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::financio::trading::TickAttribPB* PROTOBUF_NULLABLE TickPrice::unsafe_arena_release_attrib() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.TickPrice.attrib)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::financio::trading::TickAttribPB* temp = _impl_.attrib_;
  _impl_.attrib_ = nullptr;
  return temp;
}
inline ::financio::trading::TickAttribPB* PROTOBUF_NONNULL TickPrice::_internal_mutable_attrib() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.attrib_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::financio::trading::TickAttribPB>(GetArena());
    _impl_.attrib_ = reinterpret_cast<::financio::trading::TickAttribPB*>(p);
  }
  return _impl_.attrib_;
}
inline ::financio::trading::TickAttribPB* PROTOBUF_NONNULL TickPrice::mutable_attrib()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::financio::trading::TickAttribPB* _msg = _internal_mutable_attrib();
  // @@protoc_insertion_point(field_mutable:financio.trading.TickPrice.attrib)
  return _msg;
}
inline void TickPrice::set_allocated_attrib(::financio::trading::TickAttribPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attrib_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.attrib_ = reinterpret_cast<::financio::trading::TickAttribPB*>(value);
  // @@protoc_insertion_point(field_set_allocated:financio.trading.TickPrice.attrib)
}

// -------------------------------------------------------------------

// TickSize

// int32 field = 1;
inline void TickSize::clear_field() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::int32_t TickSize::field() const {
  // @@protoc_insertion_point(field_get:financio.trading.TickSize.field)
  return _internal_field();
}
inline void TickSize::set_field(::int32_t value) {
  _internal_set_field(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:financio.trading.TickSize.field)
}
inline ::int32_t TickSize::_internal_field() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.field_;
}
inline void TickSize::_internal_set_field(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.field_ = value;
}

// double size = 2;
inline void TickSize::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline double TickSize::size() const {
  // @@protoc_insertion_point(field_get:financio.trading.TickSize.size)
  return _internal_size();
}
inline void TickSize::set_size(double value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:financio.trading.TickSize.size)
}
inline double TickSize::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void TickSize::_internal_set_size(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// OrderStatus

// string status = 1;
inline void OrderStatus::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& OrderStatus::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.OrderStatus.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void OrderStatus::set_status(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.OrderStatus.status)
}
inline ::std::string* PROTOBUF_NONNULL OrderStatus::mutable_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:financio.trading.OrderStatus.status)
  return _s;
}
inline const ::std::string& OrderStatus::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.status_.Get();
}
inline void OrderStatus::_internal_set_status(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.status_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL OrderStatus::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.status_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE OrderStatus::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.OrderStatus.status)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.status_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.status_.Set("", GetArena());
  }
  return released;
}
inline void OrderStatus::set_allocated_status(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.status_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.OrderStatus.status)
}

// double filled = 2;
inline void OrderStatus::clear_filled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filled_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline double OrderStatus::filled() const {
  // @@protoc_insertion_point(field_get:financio.trading.OrderStatus.filled)
  return _internal_filled();
}
inline void OrderStatus::set_filled(double value) {
  _internal_set_filled(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:financio.trading.OrderStatus.filled)
}
inline double OrderStatus::_internal_filled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filled_;
}
inline void OrderStatus::_internal_set_filled(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filled_ = value;
}

// double remaining = 3;
inline void OrderStatus::clear_remaining() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remaining_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline double OrderStatus::remaining() const {
  // @@protoc_insertion_point(field_get:financio.trading.OrderStatus.remaining)
  return _internal_remaining();
}
inline void OrderStatus::set_remaining(double value) {
  _internal_set_remaining(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:financio.trading.OrderStatus.remaining)
}
inline double OrderStatus::_internal_remaining() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remaining_;
}
inline void OrderStatus::_internal_set_remaining(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remaining_ = value;
}

// double avg_fill_px = 4;
inline void OrderStatus::clear_avg_fill_px() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_fill_px_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline double OrderStatus::avg_fill_px() const {
  // @@protoc_insertion_point(field_get:financio.trading.OrderStatus.avg_fill_px)
  return _internal_avg_fill_px();
}
inline void OrderStatus::set_avg_fill_px(double value) {
  _internal_set_avg_fill_px(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:financio.trading.OrderStatus.avg_fill_px)
}
inline double OrderStatus::_internal_avg_fill_px() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avg_fill_px_;
}
inline void OrderStatus::_internal_set_avg_fill_px(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_fill_px_ = value;
}

// -------------------------------------------------------------------

// OrderFill

// .financio.trading.ExecutionPB exec = 1;
inline bool OrderFill::has_exec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.exec_ != nullptr);
  return value;
}
inline const ::financio::trading::ExecutionPB& OrderFill::_internal_exec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::financio::trading::ExecutionPB* p = _impl_.exec_;
  return p != nullptr ? *p : reinterpret_cast<const ::financio::trading::ExecutionPB&>(::financio::trading::_ExecutionPB_default_instance_);
}
inline const ::financio::trading::ExecutionPB& OrderFill::exec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.OrderFill.exec)
  return _internal_exec();
}
inline void OrderFill::unsafe_arena_set_allocated_exec(
    ::financio::trading::ExecutionPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exec_);
  }
  _impl_.exec_ = reinterpret_cast<::financio::trading::ExecutionPB*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.OrderFill.exec)
}
inline ::financio::trading::ExecutionPB* PROTOBUF_NULLABLE OrderFill::release_exec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::financio::trading::ExecutionPB* released = _impl_.exec_;
  _impl_.exec_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::financio::trading::ExecutionPB* PROTOBUF_NULLABLE OrderFill::unsafe_arena_release_exec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.OrderFill.exec)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::financio::trading::ExecutionPB* temp = _impl_.exec_;
  _impl_.exec_ = nullptr;
  return temp;
}
inline ::financio::trading::ExecutionPB* PROTOBUF_NONNULL OrderFill::_internal_mutable_exec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.exec_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::financio::trading::ExecutionPB>(GetArena());
    _impl_.exec_ = reinterpret_cast<::financio::trading::ExecutionPB*>(p);
  }
  return _impl_.exec_;
}
inline ::financio::trading::ExecutionPB* PROTOBUF_NONNULL OrderFill::mutable_exec()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::financio::trading::ExecutionPB* _msg = _internal_mutable_exec();
  // @@protoc_insertion_point(field_mutable:financio.trading.OrderFill.exec)
  return _msg;
}
inline void OrderFill::set_allocated_exec(::financio::trading::ExecutionPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.exec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.exec_ = reinterpret_cast<::financio::trading::ExecutionPB*>(value);
  // @@protoc_insertion_point(field_set_allocated:financio.trading.OrderFill.exec)
}

// -------------------------------------------------------------------

// HistoricalBar

// .financio.trading.BarPB bar = 1;
inline bool HistoricalBar::has_bar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bar_ != nullptr);
  return value;
}
inline const ::financio::trading::BarPB& HistoricalBar::_internal_bar() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::financio::trading::BarPB* p = _impl_.bar_;
  return p != nullptr ? *p : reinterpret_cast<const ::financio::trading::BarPB&>(::financio::trading::_BarPB_default_instance_);
}
inline const ::financio::trading::BarPB& HistoricalBar::bar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalBar.bar)
  return _internal_bar();
}
inline void HistoricalBar::unsafe_arena_set_allocated_bar(
    ::financio::trading::BarPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bar_);
  }
  _impl_.bar_ = reinterpret_cast<::financio::trading::BarPB*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.HistoricalBar.bar)
}
inline ::financio::trading::BarPB* PROTOBUF_NULLABLE HistoricalBar::release_bar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::financio::trading::BarPB* released = _impl_.bar_;
  _impl_.bar_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::financio::trading::BarPB* PROTOBUF_NULLABLE HistoricalBar::unsafe_arena_release_bar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalBar.bar)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::financio::trading::BarPB* temp = _impl_.bar_;
  _impl_.bar_ = nullptr;
  return temp;
}
inline ::financio::trading::BarPB* PROTOBUF_NONNULL HistoricalBar::_internal_mutable_bar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bar_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::financio::trading::BarPB>(GetArena());
    _impl_.bar_ = reinterpret_cast<::financio::trading::BarPB*>(p);
  }
  return _impl_.bar_;
}
inline ::financio::trading::BarPB* PROTOBUF_NONNULL HistoricalBar::mutable_bar()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::financio::trading::BarPB* _msg = _internal_mutable_bar();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalBar.bar)
  return _msg;
}
inline void HistoricalBar::set_allocated_bar(::financio::trading::BarPB* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bar_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.bar_ = reinterpret_cast<::financio::trading::BarPB*>(value);
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalBar.bar)
}

// -------------------------------------------------------------------

// HistoricalEnd

// string start = 1;
inline void HistoricalEnd::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& HistoricalEnd::start() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalEnd.start)
  return _internal_start();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalEnd::set_start(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.start_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalEnd.start)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalEnd::mutable_start()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalEnd.start)
  return _s;
}
inline const ::std::string& HistoricalEnd::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_.Get();
}
inline void HistoricalEnd::_internal_set_start(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.start_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalEnd::_internal_mutable_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.start_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalEnd::release_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalEnd.start)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.start_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalEnd::set_allocated_start(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.start_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_.IsDefault()) {
    _impl_.start_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalEnd.start)
}

// string end = 2;
inline void HistoricalEnd::clear_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& HistoricalEnd::end() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.HistoricalEnd.end)
  return _internal_end();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void HistoricalEnd::set_end(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.end_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.HistoricalEnd.end)
}
inline ::std::string* PROTOBUF_NONNULL HistoricalEnd::mutable_end()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:financio.trading.HistoricalEnd.end)
  return _s;
}
inline const ::std::string& HistoricalEnd::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_.Get();
}
inline void HistoricalEnd::_internal_set_end(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.end_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL HistoricalEnd::_internal_mutable_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.end_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE HistoricalEnd::release_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.HistoricalEnd.end)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.end_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.end_.Set("", GetArena());
  }
  return released;
}
inline void HistoricalEnd::set_allocated_end(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.end_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.end_.IsDefault()) {
    _impl_.end_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.HistoricalEnd.end)
}

// -------------------------------------------------------------------

// AccountSummary

// string account = 1;
inline void AccountSummary::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& AccountSummary::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.AccountSummary.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AccountSummary::set_account(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.AccountSummary.account)
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::mutable_account()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:financio.trading.AccountSummary.account)
  return _s;
}
inline const ::std::string& AccountSummary::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void AccountSummary::_internal_set_account(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.account_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.account_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AccountSummary::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.AccountSummary.account)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.account_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.account_.Set("", GetArena());
  }
  return released;
}
inline void AccountSummary::set_allocated_account(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.account_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_.IsDefault()) {
    _impl_.account_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.AccountSummary.account)
}

// string key = 2;
inline void AccountSummary::clear_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& AccountSummary::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.AccountSummary.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AccountSummary::set_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.AccountSummary.key)
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::mutable_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:financio.trading.AccountSummary.key)
  return _s;
}
inline const ::std::string& AccountSummary::_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_.Get();
}
inline void AccountSummary::_internal_set_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::_internal_mutable_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AccountSummary::release_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.AccountSummary.key)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.key_.Set("", GetArena());
  }
  return released;
}
inline void AccountSummary::set_allocated_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.AccountSummary.key)
}

// string value = 3;
inline void AccountSummary::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::std::string& AccountSummary::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.AccountSummary.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AccountSummary::set_value(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.AccountSummary.value)
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::mutable_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:financio.trading.AccountSummary.value)
  return _s;
}
inline const ::std::string& AccountSummary::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void AccountSummary::_internal_set_value(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.value_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  return _impl_.value_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AccountSummary::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.AccountSummary.value)
  if ((_impl_._has_bits_[0] & 0x00000004U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004U;
  auto* released = _impl_.value_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.value_.Set("", GetArena());
  }
  return released;
}
inline void AccountSummary::set_allocated_value(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.AccountSummary.value)
}

// string currency = 4;
inline void AccountSummary::clear_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.currency_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline const ::std::string& AccountSummary::currency() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.AccountSummary.currency)
  return _internal_currency();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AccountSummary::set_currency(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.currency_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.AccountSummary.currency)
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::mutable_currency()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:financio.trading.AccountSummary.currency)
  return _s;
}
inline const ::std::string& AccountSummary::_internal_currency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.currency_.Get();
}
inline void AccountSummary::_internal_set_currency(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.currency_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AccountSummary::_internal_mutable_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  return _impl_.currency_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AccountSummary::release_currency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.AccountSummary.currency)
  if ((_impl_._has_bits_[0] & 0x00000008U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008U;
  auto* released = _impl_.currency_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.currency_.Set("", GetArena());
  }
  return released;
}
inline void AccountSummary::set_allocated_currency(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }
  _impl_.currency_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.AccountSummary.currency)
}

// -------------------------------------------------------------------

// PortfolioPosition

// string account = 1;
inline void PortfolioPosition::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& PortfolioPosition::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.PortfolioPosition.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PortfolioPosition::set_account(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.PortfolioPosition.account)
}
inline ::std::string* PROTOBUF_NONNULL PortfolioPosition::mutable_account()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:financio.trading.PortfolioPosition.account)
  return _s;
}
inline const ::std::string& PortfolioPosition::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void PortfolioPosition::_internal_set_account(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.account_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PortfolioPosition::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.account_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PortfolioPosition::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.PortfolioPosition.account)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.account_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.account_.Set("", GetArena());
  }
  return released;
}
inline void PortfolioPosition::set_allocated_account(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.account_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_.IsDefault()) {
    _impl_.account_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.PortfolioPosition.account)
}

// string symbol = 2;
inline void PortfolioPosition::clear_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.symbol_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& PortfolioPosition::symbol() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.PortfolioPosition.symbol)
  return _internal_symbol();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PortfolioPosition::set_symbol(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.symbol_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.PortfolioPosition.symbol)
}
inline ::std::string* PROTOBUF_NONNULL PortfolioPosition::mutable_symbol()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:financio.trading.PortfolioPosition.symbol)
  return _s;
}
inline const ::std::string& PortfolioPosition::_internal_symbol() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.symbol_.Get();
}
inline void PortfolioPosition::_internal_set_symbol(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.symbol_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PortfolioPosition::_internal_mutable_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.symbol_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PortfolioPosition::release_symbol() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.PortfolioPosition.symbol)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.symbol_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.symbol_.Set("", GetArena());
  }
  return released;
}
inline void PortfolioPosition::set_allocated_symbol(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.symbol_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.symbol_.IsDefault()) {
    _impl_.symbol_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.PortfolioPosition.symbol)
}

// double position = 3;
inline void PortfolioPosition::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline double PortfolioPosition::position() const {
  // @@protoc_insertion_point(field_get:financio.trading.PortfolioPosition.position)
  return _internal_position();
}
inline void PortfolioPosition::set_position(double value) {
  _internal_set_position(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:financio.trading.PortfolioPosition.position)
}
inline double PortfolioPosition::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_;
}
inline void PortfolioPosition::_internal_set_position(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_ = value;
}

// double avg_cost = 4;
inline void PortfolioPosition::clear_avg_cost() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline double PortfolioPosition::avg_cost() const {
  // @@protoc_insertion_point(field_get:financio.trading.PortfolioPosition.avg_cost)
  return _internal_avg_cost();
}
inline void PortfolioPosition::set_avg_cost(double value) {
  _internal_set_avg_cost(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:financio.trading.PortfolioPosition.avg_cost)
}
inline double PortfolioPosition::_internal_avg_cost() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avg_cost_;
}
inline void PortfolioPosition::_internal_set_avg_cost(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avg_cost_ = value;
}

// -------------------------------------------------------------------

// NewsHeadline

// string provider = 1;
inline void NewsHeadline::clear_provider() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.provider_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& NewsHeadline::provider() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.NewsHeadline.provider)
  return _internal_provider();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NewsHeadline::set_provider(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.provider_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.NewsHeadline.provider)
}
inline ::std::string* PROTOBUF_NONNULL NewsHeadline::mutable_provider()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:financio.trading.NewsHeadline.provider)
  return _s;
}
inline const ::std::string& NewsHeadline::_internal_provider() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.provider_.Get();
}
inline void NewsHeadline::_internal_set_provider(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.provider_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NewsHeadline::_internal_mutable_provider() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.provider_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NewsHeadline::release_provider() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.NewsHeadline.provider)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.provider_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.provider_.Set("", GetArena());
  }
  return released;
}
inline void NewsHeadline::set_allocated_provider(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.provider_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.provider_.IsDefault()) {
    _impl_.provider_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.NewsHeadline.provider)
}

// string headline = 2;
inline void NewsHeadline::clear_headline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.headline_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& NewsHeadline::headline() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.NewsHeadline.headline)
  return _internal_headline();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NewsHeadline::set_headline(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.headline_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.NewsHeadline.headline)
}
inline ::std::string* PROTOBUF_NONNULL NewsHeadline::mutable_headline()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_headline();
  // @@protoc_insertion_point(field_mutable:financio.trading.NewsHeadline.headline)
  return _s;
}
inline const ::std::string& NewsHeadline::_internal_headline() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.headline_.Get();
}
inline void NewsHeadline::_internal_set_headline(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.headline_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NewsHeadline::_internal_mutable_headline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.headline_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NewsHeadline::release_headline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.NewsHeadline.headline)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.headline_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.headline_.Set("", GetArena());
  }
  return released;
}
inline void NewsHeadline::set_allocated_headline(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.headline_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.headline_.IsDefault()) {
    _impl_.headline_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.NewsHeadline.headline)
}

// -------------------------------------------------------------------

// Pong

// string note = 1;
inline void Pong::clear_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.note_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& Pong::note() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.Pong.note)
  return _internal_note();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Pong::set_note(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.note_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:financio.trading.Pong.note)
}
inline ::std::string* PROTOBUF_NONNULL Pong::mutable_note()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:financio.trading.Pong.note)
  return _s;
}
inline const ::std::string& Pong::_internal_note() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.note_.Get();
}
inline void Pong::_internal_set_note(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.note_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Pong::_internal_mutable_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.note_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Pong::release_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.Pong.note)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.note_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.note_.Set("", GetArena());
  }
  return released;
}
inline void Pong::set_allocated_note(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.note_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:financio.trading.Pong.note)
}

// -------------------------------------------------------------------

// StateMessage

// .financio.trading.StateType type = 1;
inline void StateMessage::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::financio::trading::StateType StateMessage::type() const {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.type)
  return _internal_type();
}
inline void StateMessage::set_type(::financio::trading::StateType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:financio.trading.StateMessage.type)
}
inline ::financio::trading::StateType StateMessage::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::financio::trading::StateType>(_impl_.type_);
}
inline void StateMessage::_internal_set_type(::financio::trading::StateType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// int64 id = 2;
inline void StateMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::int64_t StateMessage::id() const {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.id)
  return _internal_id();
}
inline void StateMessage::set_id(::int64_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:financio.trading.StateMessage.id)
}
inline ::int64_t StateMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void StateMessage::_internal_set_id(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// .google.protobuf.Timestamp ts = 3;
inline bool StateMessage::has_ts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ts_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& StateMessage::_internal_ts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.ts_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& StateMessage::ts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.ts)
  return _internal_ts();
}
inline void StateMessage::unsafe_arena_set_allocated_ts(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ts_);
  }
  _impl_.ts_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.ts)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE StateMessage::release_ts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::google::protobuf::Timestamp* released = _impl_.ts_;
  _impl_.ts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_ts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.ts)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::google::protobuf::Timestamp* temp = _impl_.ts_;
  _impl_.ts_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL StateMessage::_internal_mutable_ts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.ts_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.ts_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL StateMessage::mutable_ts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_ts();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.ts)
  return _msg;
}
inline void StateMessage::set_allocated_ts(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.ts_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:financio.trading.StateMessage.ts)
}

// .financio.trading.Error error = 10;
inline bool StateMessage::has_error() const {
  return payload_case() == kError;
}
inline bool StateMessage::_internal_has_error() const {
  return payload_case() == kError;
}
inline void StateMessage::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void StateMessage::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kError) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.error_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.error_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::Error* PROTOBUF_NULLABLE StateMessage::release_error() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.error)
  if (payload_case() == kError) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::Error*>(_impl_.payload_.error_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::Error& StateMessage::_internal_error() const {
  return payload_case() == kError ? *reinterpret_cast<::financio::trading::Error*>(_impl_.payload_.error_) : reinterpret_cast<::financio::trading::Error&>(::financio::trading::_Error_default_instance_);
}
inline const ::financio::trading::Error& StateMessage::error() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.error)
  return _internal_error();
}
inline ::financio::trading::Error* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.error)
  if (payload_case() == kError) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::Error*>(_impl_.payload_.error_);
    _impl_.payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_error(
    ::financio::trading::Error* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_error();
    _impl_.payload_.error_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.error)
}
inline ::financio::trading::Error* PROTOBUF_NONNULL StateMessage::_internal_mutable_error() {
  if (payload_case() != kError) {
    clear_payload();
    set_has_error();
    _impl_.payload_.error_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::Error>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::Error*>(_impl_.payload_.error_);
}
inline ::financio::trading::Error* PROTOBUF_NONNULL StateMessage::mutable_error()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.error)
  return _msg;
}

// .financio.trading.TickPrice tick_price = 11;
inline bool StateMessage::has_tick_price() const {
  return payload_case() == kTickPrice;
}
inline bool StateMessage::_internal_has_tick_price() const {
  return payload_case() == kTickPrice;
}
inline void StateMessage::set_has_tick_price() {
  _impl_._oneof_case_[0] = kTickPrice;
}
inline void StateMessage::clear_tick_price() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kTickPrice) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.tick_price_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.tick_price_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::TickPrice* PROTOBUF_NULLABLE StateMessage::release_tick_price() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.tick_price)
  if (payload_case() == kTickPrice) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::TickPrice*>(_impl_.payload_.tick_price_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.tick_price_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::TickPrice& StateMessage::_internal_tick_price() const {
  return payload_case() == kTickPrice ? *reinterpret_cast<::financio::trading::TickPrice*>(_impl_.payload_.tick_price_) : reinterpret_cast<::financio::trading::TickPrice&>(::financio::trading::_TickPrice_default_instance_);
}
inline const ::financio::trading::TickPrice& StateMessage::tick_price() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.tick_price)
  return _internal_tick_price();
}
inline ::financio::trading::TickPrice* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_tick_price() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.tick_price)
  if (payload_case() == kTickPrice) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::TickPrice*>(_impl_.payload_.tick_price_);
    _impl_.payload_.tick_price_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_tick_price(
    ::financio::trading::TickPrice* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_tick_price();
    _impl_.payload_.tick_price_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.tick_price)
}
inline ::financio::trading::TickPrice* PROTOBUF_NONNULL StateMessage::_internal_mutable_tick_price() {
  if (payload_case() != kTickPrice) {
    clear_payload();
    set_has_tick_price();
    _impl_.payload_.tick_price_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::TickPrice>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::TickPrice*>(_impl_.payload_.tick_price_);
}
inline ::financio::trading::TickPrice* PROTOBUF_NONNULL StateMessage::mutable_tick_price()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::TickPrice* _msg = _internal_mutable_tick_price();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.tick_price)
  return _msg;
}

// .financio.trading.TickSize tick_size = 12;
inline bool StateMessage::has_tick_size() const {
  return payload_case() == kTickSize;
}
inline bool StateMessage::_internal_has_tick_size() const {
  return payload_case() == kTickSize;
}
inline void StateMessage::set_has_tick_size() {
  _impl_._oneof_case_[0] = kTickSize;
}
inline void StateMessage::clear_tick_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kTickSize) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.tick_size_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.tick_size_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::TickSize* PROTOBUF_NULLABLE StateMessage::release_tick_size() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.tick_size)
  if (payload_case() == kTickSize) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::TickSize*>(_impl_.payload_.tick_size_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.tick_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::TickSize& StateMessage::_internal_tick_size() const {
  return payload_case() == kTickSize ? *reinterpret_cast<::financio::trading::TickSize*>(_impl_.payload_.tick_size_) : reinterpret_cast<::financio::trading::TickSize&>(::financio::trading::_TickSize_default_instance_);
}
inline const ::financio::trading::TickSize& StateMessage::tick_size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.tick_size)
  return _internal_tick_size();
}
inline ::financio::trading::TickSize* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_tick_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.tick_size)
  if (payload_case() == kTickSize) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::TickSize*>(_impl_.payload_.tick_size_);
    _impl_.payload_.tick_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_tick_size(
    ::financio::trading::TickSize* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_tick_size();
    _impl_.payload_.tick_size_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.tick_size)
}
inline ::financio::trading::TickSize* PROTOBUF_NONNULL StateMessage::_internal_mutable_tick_size() {
  if (payload_case() != kTickSize) {
    clear_payload();
    set_has_tick_size();
    _impl_.payload_.tick_size_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::TickSize>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::TickSize*>(_impl_.payload_.tick_size_);
}
inline ::financio::trading::TickSize* PROTOBUF_NONNULL StateMessage::mutable_tick_size()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::TickSize* _msg = _internal_mutable_tick_size();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.tick_size)
  return _msg;
}

// .financio.trading.OrderStatus order_status = 13;
inline bool StateMessage::has_order_status() const {
  return payload_case() == kOrderStatus;
}
inline bool StateMessage::_internal_has_order_status() const {
  return payload_case() == kOrderStatus;
}
inline void StateMessage::set_has_order_status() {
  _impl_._oneof_case_[0] = kOrderStatus;
}
inline void StateMessage::clear_order_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kOrderStatus) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.order_status_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.order_status_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::OrderStatus* PROTOBUF_NULLABLE StateMessage::release_order_status() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.order_status)
  if (payload_case() == kOrderStatus) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::OrderStatus*>(_impl_.payload_.order_status_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::OrderStatus& StateMessage::_internal_order_status() const {
  return payload_case() == kOrderStatus ? *reinterpret_cast<::financio::trading::OrderStatus*>(_impl_.payload_.order_status_) : reinterpret_cast<::financio::trading::OrderStatus&>(::financio::trading::_OrderStatus_default_instance_);
}
inline const ::financio::trading::OrderStatus& StateMessage::order_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.order_status)
  return _internal_order_status();
}
inline ::financio::trading::OrderStatus* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_order_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.order_status)
  if (payload_case() == kOrderStatus) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::OrderStatus*>(_impl_.payload_.order_status_);
    _impl_.payload_.order_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_order_status(
    ::financio::trading::OrderStatus* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_status();
    _impl_.payload_.order_status_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.order_status)
}
inline ::financio::trading::OrderStatus* PROTOBUF_NONNULL StateMessage::_internal_mutable_order_status() {
  if (payload_case() != kOrderStatus) {
    clear_payload();
    set_has_order_status();
    _impl_.payload_.order_status_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::OrderStatus>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::OrderStatus*>(_impl_.payload_.order_status_);
}
inline ::financio::trading::OrderStatus* PROTOBUF_NONNULL StateMessage::mutable_order_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::OrderStatus* _msg = _internal_mutable_order_status();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.order_status)
  return _msg;
}

// .financio.trading.OrderFill order_filled = 14;
inline bool StateMessage::has_order_filled() const {
  return payload_case() == kOrderFilled;
}
inline bool StateMessage::_internal_has_order_filled() const {
  return payload_case() == kOrderFilled;
}
inline void StateMessage::set_has_order_filled() {
  _impl_._oneof_case_[0] = kOrderFilled;
}
inline void StateMessage::clear_order_filled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kOrderFilled) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.order_filled_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.order_filled_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::OrderFill* PROTOBUF_NULLABLE StateMessage::release_order_filled() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.order_filled)
  if (payload_case() == kOrderFilled) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::OrderFill*>(_impl_.payload_.order_filled_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.order_filled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::OrderFill& StateMessage::_internal_order_filled() const {
  return payload_case() == kOrderFilled ? *reinterpret_cast<::financio::trading::OrderFill*>(_impl_.payload_.order_filled_) : reinterpret_cast<::financio::trading::OrderFill&>(::financio::trading::_OrderFill_default_instance_);
}
inline const ::financio::trading::OrderFill& StateMessage::order_filled() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.order_filled)
  return _internal_order_filled();
}
inline ::financio::trading::OrderFill* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_order_filled() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.order_filled)
  if (payload_case() == kOrderFilled) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::OrderFill*>(_impl_.payload_.order_filled_);
    _impl_.payload_.order_filled_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_order_filled(
    ::financio::trading::OrderFill* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_order_filled();
    _impl_.payload_.order_filled_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.order_filled)
}
inline ::financio::trading::OrderFill* PROTOBUF_NONNULL StateMessage::_internal_mutable_order_filled() {
  if (payload_case() != kOrderFilled) {
    clear_payload();
    set_has_order_filled();
    _impl_.payload_.order_filled_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::OrderFill>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::OrderFill*>(_impl_.payload_.order_filled_);
}
inline ::financio::trading::OrderFill* PROTOBUF_NONNULL StateMessage::mutable_order_filled()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::OrderFill* _msg = _internal_mutable_order_filled();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.order_filled)
  return _msg;
}

// .financio.trading.HistoricalBar hist_bar = 20;
inline bool StateMessage::has_hist_bar() const {
  return payload_case() == kHistBar;
}
inline bool StateMessage::_internal_has_hist_bar() const {
  return payload_case() == kHistBar;
}
inline void StateMessage::set_has_hist_bar() {
  _impl_._oneof_case_[0] = kHistBar;
}
inline void StateMessage::clear_hist_bar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHistBar) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.hist_bar_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.hist_bar_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::HistoricalBar* PROTOBUF_NULLABLE StateMessage::release_hist_bar() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.hist_bar)
  if (payload_case() == kHistBar) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::HistoricalBar*>(_impl_.payload_.hist_bar_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.hist_bar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::HistoricalBar& StateMessage::_internal_hist_bar() const {
  return payload_case() == kHistBar ? *reinterpret_cast<::financio::trading::HistoricalBar*>(_impl_.payload_.hist_bar_) : reinterpret_cast<::financio::trading::HistoricalBar&>(::financio::trading::_HistoricalBar_default_instance_);
}
inline const ::financio::trading::HistoricalBar& StateMessage::hist_bar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.hist_bar)
  return _internal_hist_bar();
}
inline ::financio::trading::HistoricalBar* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_hist_bar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.hist_bar)
  if (payload_case() == kHistBar) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::HistoricalBar*>(_impl_.payload_.hist_bar_);
    _impl_.payload_.hist_bar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_hist_bar(
    ::financio::trading::HistoricalBar* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_hist_bar();
    _impl_.payload_.hist_bar_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.hist_bar)
}
inline ::financio::trading::HistoricalBar* PROTOBUF_NONNULL StateMessage::_internal_mutable_hist_bar() {
  if (payload_case() != kHistBar) {
    clear_payload();
    set_has_hist_bar();
    _impl_.payload_.hist_bar_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::HistoricalBar>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::HistoricalBar*>(_impl_.payload_.hist_bar_);
}
inline ::financio::trading::HistoricalBar* PROTOBUF_NONNULL StateMessage::mutable_hist_bar()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::HistoricalBar* _msg = _internal_mutable_hist_bar();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.hist_bar)
  return _msg;
}

// .financio.trading.HistoricalEnd hist_end = 21;
inline bool StateMessage::has_hist_end() const {
  return payload_case() == kHistEnd;
}
inline bool StateMessage::_internal_has_hist_end() const {
  return payload_case() == kHistEnd;
}
inline void StateMessage::set_has_hist_end() {
  _impl_._oneof_case_[0] = kHistEnd;
}
inline void StateMessage::clear_hist_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kHistEnd) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.hist_end_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.hist_end_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::HistoricalEnd* PROTOBUF_NULLABLE StateMessage::release_hist_end() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.hist_end)
  if (payload_case() == kHistEnd) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::HistoricalEnd*>(_impl_.payload_.hist_end_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.hist_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::HistoricalEnd& StateMessage::_internal_hist_end() const {
  return payload_case() == kHistEnd ? *reinterpret_cast<::financio::trading::HistoricalEnd*>(_impl_.payload_.hist_end_) : reinterpret_cast<::financio::trading::HistoricalEnd&>(::financio::trading::_HistoricalEnd_default_instance_);
}
inline const ::financio::trading::HistoricalEnd& StateMessage::hist_end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.hist_end)
  return _internal_hist_end();
}
inline ::financio::trading::HistoricalEnd* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_hist_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.hist_end)
  if (payload_case() == kHistEnd) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::HistoricalEnd*>(_impl_.payload_.hist_end_);
    _impl_.payload_.hist_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_hist_end(
    ::financio::trading::HistoricalEnd* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_hist_end();
    _impl_.payload_.hist_end_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.hist_end)
}
inline ::financio::trading::HistoricalEnd* PROTOBUF_NONNULL StateMessage::_internal_mutable_hist_end() {
  if (payload_case() != kHistEnd) {
    clear_payload();
    set_has_hist_end();
    _impl_.payload_.hist_end_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::HistoricalEnd>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::HistoricalEnd*>(_impl_.payload_.hist_end_);
}
inline ::financio::trading::HistoricalEnd* PROTOBUF_NONNULL StateMessage::mutable_hist_end()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::HistoricalEnd* _msg = _internal_mutable_hist_end();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.hist_end)
  return _msg;
}

// .financio.trading.AccountSummary account_summary = 30;
inline bool StateMessage::has_account_summary() const {
  return payload_case() == kAccountSummary;
}
inline bool StateMessage::_internal_has_account_summary() const {
  return payload_case() == kAccountSummary;
}
inline void StateMessage::set_has_account_summary() {
  _impl_._oneof_case_[0] = kAccountSummary;
}
inline void StateMessage::clear_account_summary() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAccountSummary) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.account_summary_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.account_summary_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::AccountSummary* PROTOBUF_NULLABLE StateMessage::release_account_summary() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.account_summary)
  if (payload_case() == kAccountSummary) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::AccountSummary*>(_impl_.payload_.account_summary_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.account_summary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::AccountSummary& StateMessage::_internal_account_summary() const {
  return payload_case() == kAccountSummary ? *reinterpret_cast<::financio::trading::AccountSummary*>(_impl_.payload_.account_summary_) : reinterpret_cast<::financio::trading::AccountSummary&>(::financio::trading::_AccountSummary_default_instance_);
}
inline const ::financio::trading::AccountSummary& StateMessage::account_summary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.account_summary)
  return _internal_account_summary();
}
inline ::financio::trading::AccountSummary* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_account_summary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.account_summary)
  if (payload_case() == kAccountSummary) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::AccountSummary*>(_impl_.payload_.account_summary_);
    _impl_.payload_.account_summary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_account_summary(
    ::financio::trading::AccountSummary* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_account_summary();
    _impl_.payload_.account_summary_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.account_summary)
}
inline ::financio::trading::AccountSummary* PROTOBUF_NONNULL StateMessage::_internal_mutable_account_summary() {
  if (payload_case() != kAccountSummary) {
    clear_payload();
    set_has_account_summary();
    _impl_.payload_.account_summary_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::AccountSummary>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::AccountSummary*>(_impl_.payload_.account_summary_);
}
inline ::financio::trading::AccountSummary* PROTOBUF_NONNULL StateMessage::mutable_account_summary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::AccountSummary* _msg = _internal_mutable_account_summary();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.account_summary)
  return _msg;
}

// .financio.trading.PortfolioPosition portfolio_update = 31;
inline bool StateMessage::has_portfolio_update() const {
  return payload_case() == kPortfolioUpdate;
}
inline bool StateMessage::_internal_has_portfolio_update() const {
  return payload_case() == kPortfolioUpdate;
}
inline void StateMessage::set_has_portfolio_update() {
  _impl_._oneof_case_[0] = kPortfolioUpdate;
}
inline void StateMessage::clear_portfolio_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPortfolioUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.portfolio_update_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.portfolio_update_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::PortfolioPosition* PROTOBUF_NULLABLE StateMessage::release_portfolio_update() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.portfolio_update)
  if (payload_case() == kPortfolioUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::PortfolioPosition*>(_impl_.payload_.portfolio_update_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.portfolio_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::PortfolioPosition& StateMessage::_internal_portfolio_update() const {
  return payload_case() == kPortfolioUpdate ? *reinterpret_cast<::financio::trading::PortfolioPosition*>(_impl_.payload_.portfolio_update_) : reinterpret_cast<::financio::trading::PortfolioPosition&>(::financio::trading::_PortfolioPosition_default_instance_);
}
inline const ::financio::trading::PortfolioPosition& StateMessage::portfolio_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.portfolio_update)
  return _internal_portfolio_update();
}
inline ::financio::trading::PortfolioPosition* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_portfolio_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.portfolio_update)
  if (payload_case() == kPortfolioUpdate) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::PortfolioPosition*>(_impl_.payload_.portfolio_update_);
    _impl_.payload_.portfolio_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_portfolio_update(
    ::financio::trading::PortfolioPosition* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_portfolio_update();
    _impl_.payload_.portfolio_update_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.portfolio_update)
}
inline ::financio::trading::PortfolioPosition* PROTOBUF_NONNULL StateMessage::_internal_mutable_portfolio_update() {
  if (payload_case() != kPortfolioUpdate) {
    clear_payload();
    set_has_portfolio_update();
    _impl_.payload_.portfolio_update_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::PortfolioPosition>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::PortfolioPosition*>(_impl_.payload_.portfolio_update_);
}
inline ::financio::trading::PortfolioPosition* PROTOBUF_NONNULL StateMessage::mutable_portfolio_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::PortfolioPosition* _msg = _internal_mutable_portfolio_update();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.portfolio_update)
  return _msg;
}

// .financio.trading.NewsHeadline news_headline = 32;
inline bool StateMessage::has_news_headline() const {
  return payload_case() == kNewsHeadline;
}
inline bool StateMessage::_internal_has_news_headline() const {
  return payload_case() == kNewsHeadline;
}
inline void StateMessage::set_has_news_headline() {
  _impl_._oneof_case_[0] = kNewsHeadline;
}
inline void StateMessage::clear_news_headline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kNewsHeadline) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.news_headline_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.news_headline_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::NewsHeadline* PROTOBUF_NULLABLE StateMessage::release_news_headline() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.news_headline)
  if (payload_case() == kNewsHeadline) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::NewsHeadline*>(_impl_.payload_.news_headline_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.news_headline_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::NewsHeadline& StateMessage::_internal_news_headline() const {
  return payload_case() == kNewsHeadline ? *reinterpret_cast<::financio::trading::NewsHeadline*>(_impl_.payload_.news_headline_) : reinterpret_cast<::financio::trading::NewsHeadline&>(::financio::trading::_NewsHeadline_default_instance_);
}
inline const ::financio::trading::NewsHeadline& StateMessage::news_headline() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.news_headline)
  return _internal_news_headline();
}
inline ::financio::trading::NewsHeadline* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_news_headline() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.news_headline)
  if (payload_case() == kNewsHeadline) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::NewsHeadline*>(_impl_.payload_.news_headline_);
    _impl_.payload_.news_headline_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_news_headline(
    ::financio::trading::NewsHeadline* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_news_headline();
    _impl_.payload_.news_headline_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.news_headline)
}
inline ::financio::trading::NewsHeadline* PROTOBUF_NONNULL StateMessage::_internal_mutable_news_headline() {
  if (payload_case() != kNewsHeadline) {
    clear_payload();
    set_has_news_headline();
    _impl_.payload_.news_headline_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::NewsHeadline>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::NewsHeadline*>(_impl_.payload_.news_headline_);
}
inline ::financio::trading::NewsHeadline* PROTOBUF_NONNULL StateMessage::mutable_news_headline()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::NewsHeadline* _msg = _internal_mutable_news_headline();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.news_headline)
  return _msg;
}

// .financio.trading.Pong pong = 40;
inline bool StateMessage::has_pong() const {
  return payload_case() == kPong;
}
inline bool StateMessage::_internal_has_pong() const {
  return payload_case() == kPong;
}
inline void StateMessage::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void StateMessage::clear_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kPong) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.pong_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.pong_);
    }
    clear_has_payload();
  }
}
inline ::financio::trading::Pong* PROTOBUF_NULLABLE StateMessage::release_pong() {
  // @@protoc_insertion_point(field_release:financio.trading.StateMessage.pong)
  if (payload_case() == kPong) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::Pong*>(_impl_.payload_.pong_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::financio::trading::Pong& StateMessage::_internal_pong() const {
  return payload_case() == kPong ? *reinterpret_cast<::financio::trading::Pong*>(_impl_.payload_.pong_) : reinterpret_cast<::financio::trading::Pong&>(::financio::trading::_Pong_default_instance_);
}
inline const ::financio::trading::Pong& StateMessage::pong() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:financio.trading.StateMessage.pong)
  return _internal_pong();
}
inline ::financio::trading::Pong* PROTOBUF_NULLABLE StateMessage::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:financio.trading.StateMessage.pong)
  if (payload_case() == kPong) {
    clear_has_payload();
    auto* temp = reinterpret_cast<::financio::trading::Pong*>(_impl_.payload_.pong_);
    _impl_.payload_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StateMessage::unsafe_arena_set_allocated_pong(
    ::financio::trading::Pong* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_pong();
    _impl_.payload_.pong_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:financio.trading.StateMessage.pong)
}
inline ::financio::trading::Pong* PROTOBUF_NONNULL StateMessage::_internal_mutable_pong() {
  if (payload_case() != kPong) {
    clear_payload();
    set_has_pong();
    _impl_.payload_.pong_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::financio::trading::Pong>(GetArena()));
  }
  return reinterpret_cast<::financio::trading::Pong*>(_impl_.payload_.pong_);
}
inline ::financio::trading::Pong* PROTOBUF_NONNULL StateMessage::mutable_pong()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::financio::trading::Pong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:financio.trading.StateMessage.pong)
  return _msg;
}

inline bool StateMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void StateMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline StateMessage::PayloadCase StateMessage::payload_case() const {
  return StateMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trading
}  // namespace financio


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // trading_2fstate_2eproto_2epb_2eh
